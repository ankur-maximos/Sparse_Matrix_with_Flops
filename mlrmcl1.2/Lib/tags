!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AND	macros.h	91;"	d
APLUSAT	defs.h	107;"	d
ASSERT	macros.h	182;"	d
ASSERT	macros.h	189;"	d
ASSERTP	macros.h	193;"	d
ASSERTP	macros.h	201;"	d
Allocate2WayNodePartitionMemory	rename.h	409;"	d
Allocate2WayPartitionMemory	rename.h	388;"	d
AllocateKWayPartitionMemory	rename.h	166;"	d
AllocateVolKWayPartitionMemory	rename.h	189;"	d
AllocateWorkSpace	memory.c	/^void AllocateWorkSpace(CtrlType *ctrl, GraphType *graph, int nparts)$/;"	f
AllocateWorkSpace	rename.h	220;"	d
AreAllBelow	rename.h	342;"	d
AreAllHVwgtsAbove	rename.h	286;"	d
AreAllHVwgtsBelow	rename.h	285;"	d
AreAllVwgtsAbove	rename.h	340;"	d
AreAllVwgtsBelow	rename.h	338;"	d
AreAllVwgtsBelowFast	rename.h	308;"	d
AreAnyVwgtsBelow	rename.h	339;"	d
AtimesATranspose	mclbase.c	/^Matrix* AtimesATranspose(Matrix* A, wgttype*$/;"	f
AtimesATransposeBlocking	mclbase.c	/^Matrix* AtimesATransposeBlocking(Matrix* A, wgttype* outerDiagonalFactor,$/;"	f
AuxTmr1	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr2	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr3	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr4	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr5	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr6	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
BCPLUSCC	defs.h	106;"	d
BNDDelete	macros.h	168;"	d
BNDInsert	macros.h	161;"	d
Balance2Way	rename.h	75;"	d
BetterBalance	rename.h	243;"	d
BetterVBalance	rename.h	307;"	d
Bnd2WayBalance	rename.h	76;"	d
BucketSortKeysInc	rename.h	81;"	d
BucketSortKeysInc	util.c	/^void BucketSortKeysInc(int n, int max, idxtype *keys, idxtype *tperm, idxtype *perm)$/;"	f
CFLAGS	Makefile	/^CFLAGS = $(COPTIONS) $(OPTFLAGS) $(INCLUDES)$/;"	m
COARSEN_FRACTION	defs.h	221;"	d
COARSEN_FRACTION2	defs.h	222;"	d
COMPRESSION_FRACTION	defs.h	225;"	d
CType	struct.h	/^  int CType;			\/* The type of coarsening *\/$/;"	m	struct:controldef
Change2CNumbering	rename.h	121;"	d
Change2FNumbering	rename.h	122;"	d
Change2FNumbering2	rename.h	123;"	d
Change2FNumberingOrder	rename.h	124;"	d
ChangeMesh2CNumbering	rename.h	125;"	d
ChangeMesh2FNumbering	rename.h	126;"	d
ChangeMesh2FNumbering2	rename.h	127;"	d
CheckBnd	rename.h	103;"	d
CheckBnd2	rename.h	104;"	d
CheckGraph	io.c	/^int CheckGraph(GraphType *graph)$/;"	f
CheckHeap	rename.h	383;"	d
CheckNodeBnd	rename.h	105;"	d
CheckNodePartitionParams	rename.h	107;"	d
CheckRInfo	rename.h	106;"	d
CheckVolKWayPartitionParams	rename.h	182;"	d
Coarsen2Way	coarsen.c	/^GraphType *Coarsen2Way(CtrlType *ctrl, GraphType *graph)$/;"	f
Coarsen2Way	rename.h	93;"	d
CoarsenTmr	struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
CoarsenTo	struct.h	/^  int CoarsenTo;		\/* The # of vertices in the coarsest graph *\/$/;"	m	struct:controldef
CompressGraph	rename.h	97;"	d
Compute2WayHLoadImbalance	rename.h	244;"	d
Compute2WayHLoadImbalanceVec	rename.h	245;"	d
Compute2WayNodePartitionParams	rename.h	410;"	d
Compute2WayPartitionParams	rename.h	389;"	d
ComputeAdjWgtSums	metrics.c	/^void ComputeAdjWgtSums(GraphType* graph)$/;"	f
ComputeCoarseGraphSize	rename.h	113;"	d
ComputeConductance	metrics.c	/^float ComputeConductance(GraphType *graph, idxtype *where, int npart)$/;"	f
ComputeCut	metrics.c	/^int ComputeCut(GraphType *graph, idxtype *where)$/;"	f
ComputeCut	rename.h	102;"	d
ComputeElementBalance	rename.h	417;"	d
ComputeHKWayLoadImbalance	rename.h	287;"	d
ComputeKWayBalanceBoundary	rename.h	171;"	d
ComputeKWayBoundary	rename.h	170;"	d
ComputeKWayPartitionParams	rename.h	167;"	d
ComputeKWayVolGains	rename.h	191;"	d
ComputeKWayVolume	rename.h	180;"	d
ComputeLoadImbalance	rename.h	341;"	d
ComputeMaxNodeGain	rename.h	404;"	d
ComputeNCut	metrics.c	/^float ComputeNCut(GraphType *graph, idxtype *where, int npart)$/;"	f
ComputeNCutVector	metrics.c	/^float ComputeNCutVector(GraphType *graph, idxtype *where, int$/;"	f
ComputeNumEdgesCut	metrics.c	/^int ComputeNumEdgesCut(GraphType* graph, idxtype* where)$/;"	f
ComputePartitionBalance	rename.h	416;"	d
ComputePartitionInfo	rename.h	415;"	d
ComputeSubDomainGraph	rename.h	424;"	d
ComputeVolKWayBalanceBoundary	rename.h	194;"	d
ComputeVolKWayBoundary	rename.h	193;"	d
ComputeVolKWayPartitionParams	rename.h	190;"	d
ComputeVolSubDomainGraph	rename.h	183;"	d
ComputeVolSubset	metrics.c	/^idxtype ComputeVolSubset(GraphType* graph, idxtype* bisection)$/;"	f
ComputeVolume	rename.h	181;"	d
ConstructMinCoverSeparator	rename.h	396;"	d
ConstructMinCoverSeparator0	rename.h	395;"	d
ConstructSeparator	rename.h	394;"	d
ContractTmr	struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
CreateCoarseGraph	ccgraph.c	/^void CreateCoarseGraph(CtrlType *ctrl, GraphType *graph, int cnvtxs, idxtype *match, idxtype *perm)$/;"	f
CreateCoarseGraph	rename.h	85;"	d
CreateCoarseGraphNoMask	ccgraph.c	/^void CreateCoarseGraphNoMask(CtrlType *ctrl, GraphType *graph, int cnvtxs, idxtype *match, idxtype *perm)$/;"	f
CreateCoarseGraphNoMask	rename.h	86;"	d
CreateCoarseGraph_NVW	ccgraph.c	/^void CreateCoarseGraph_NVW(CtrlType *ctrl, GraphType *graph, int cnvtxs, idxtype *match, idxtype *perm)$/;"	f
CreateCoarseGraph_NVW	rename.h	87;"	d
CreateCoarseGraph_PowerLaw	ccgraph.c	/^void CreateCoarseGraph_PowerLaw(CtrlType *ctrl, GraphType *graph,$/;"	f
CreateGraph	memory.c	/^GraphType *CreateGraph(void)$/;"	f
CreateGraph	rename.h	226;"	d
CtrlType	struct.h	/^typedef struct controldef CtrlType;$/;"	t	typeref:struct:controldef
DBG_COARSEN	defs.h	236;"	d
DBG_IPART	defs.h	238;"	d
DBG_KWAYPINFO	defs.h	240;"	d
DBG_MOVEINFO	defs.h	239;"	d
DBG_OUTPUT	defs.h	235;"	d
DBG_REFINE	defs.h	237;"	d
DBG_SEPINFO	defs.h	241;"	d
DBG_TIME	defs.h	234;"	d
DirToUndirOptions	struct.h	/^typedef struct dirToUndirOptionsDef DirToUndirOptions;$/;"	t	typeref:struct:dirToUndirOptionsDef
EDegreeType	struct.h	/^typedef struct edegreedef EDegreeType;$/;"	t	typeref:struct:edegreedef
EliminateComponents	rename.h	427;"	d
EliminateSubDomainEdges	rename.h	425;"	d
EliminateVolSubDomainEdges	rename.h	184;"	d
EstimateCFraction	rename.h	112;"	d
FM_2WayEdgeRefine	rename.h	117;"	d
FM_2WayNodeBalance	rename.h	403;"	d
FM_2WayNodeRefine	rename.h	400;"	d
FM_2WayNodeRefineEqWgt	rename.h	401;"	d
FM_2WayNodeRefine_OneSided	rename.h	402;"	d
FindComponents	rename.h	139;"	d
FreeGraph	memory.c	/^void FreeGraph(GraphType *graph) $/;"	f
FreeGraph	rename.h	228;"	d
FreeWorkSpace	memory.c	/^void FreeWorkSpace(CtrlType *ctrl, GraphType *graph)$/;"	f
FreeWorkSpace	rename.h	221;"	d
GKfree	rename.h	439;"	d
GKfree	util.c	/^void GKfree(void **ptr1,...)$/;"	f
GKmalloc	macros.h	131;"	d
GKmalloc	rename.h	446;"	d
GKmalloc	util.c	/^void *GKmalloc(int nbytes, const char *msg)$/;"	f
GKmalloc	util.c	/^void *GKmalloc(long nbytes, const char *msg)$/;"	f
General2WayBalance	rename.h	77;"	d
GraphType	struct.h	/^typedef struct graphdef GraphType;$/;"	t	typeref:struct:graphdef
Greedy_KWayEdgeBalance	rename.h	161;"	d
Greedy_KWayEdgeBalanceMConn	rename.h	422;"	d
Greedy_KWayEdgeRefine	rename.h	160;"	d
Greedy_KWayVolBalance	rename.h	177;"	d
Greedy_KWayVolBalanceMConn	rename.h	178;"	d
GrowBisection	rename.h	145;"	d
GrowBisectionNode	rename.h	146;"	d
HASHFCT	macros.h	105;"	d
HEXDUALMETIS	rename.h	234;"	d
HEXNODALMETIS	rename.h	237;"	d
HORIZONTAL_IMBALANCE	defs.h	231;"	d
HTABLE_EMPTY	defs.h	213;"	d
HTLENGTH	defs.h	84;"	d
Hashtable	struct.h	/^typedef struct hashtabledef Hashtable;$/;"	t	typeref:struct:hashtabledef
IDF	defs.h	113;"	d
IDXTYPE_INT	struct.h	74;"	d
IFSET	macros.h	120;"	d
INCLUDES	Makefile	/^INCLUDES = -I. $/;"	m
INC_DEC	macros.h	98;"	d
INVD	defs.h	112;"	d
INVNORM	defs.h	114;"	d
INVSQRTD	defs.h	111;"	d
IPART_GGPKL	defs.h	188;"	d
IPART_GGPKLNODE	defs.h	189;"	d
IPART_McHPMETIS	defs.h	209;"	d
IPART_McPMETIS	defs.h	208;"	d
IPART_PMETIS	defs.h	196;"	d
IPART_RANDOM	defs.h	190;"	d
IType	struct.h	/^  int IType;			\/* The type of initial partitioning *\/$/;"	m	struct:controldef
Init2WayPartition	rename.h	143;"	d
InitGraph	memory.c	/^void InitGraph(GraphType *graph) $/;"	f
InitGraph	rename.h	227;"	d
InitPartTmr	struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
InitRandom	rename.h	471;"	d
InitRandom	util.c	/^void InitRandom(int seed)$/;"	f
InitSeparator	rename.h	144;"	d
InitTimers	rename.h	432;"	d
InitTimers	util.c	/^void InitTimers(CtrlType *ctrl)$/;"	f
IsBalanced	rename.h	169;"	d
IsBetter2wayBalance	rename.h	251;"	d
IsConnected	rename.h	137;"	d
IsConnected2	rename.h	138;"	d
IsConnectedSubdomain	rename.h	136;"	d
IsHBalanceBetterFT	rename.h	289;"	d
IsHBalanceBetterTT	rename.h	290;"	d
IsSeparable	rename.h	108;"	d
KMETIS_CTYPE	defs.h	124;"	d
KMETIS_DBGLVL	defs.h	127;"	d
KMETIS_ITYPE	defs.h	125;"	d
KMETIS_RTYPE	defs.h	126;"	d
KVMETIS_CTYPE	defs.h	157;"	d
KVMETIS_DBGLVL	defs.h	160;"	d
KVMETIS_ITYPE	defs.h	158;"	d
KVMETIS_RTYPE	defs.h	159;"	d
KWayVolUpdate	rename.h	179;"	d
KeyValueType	struct.h	/^struct KeyValueType {$/;"	s
KeyValueType	struct.h	/^typedef struct KeyValueType KeyValueType;$/;"	t	typeref:struct:KeyValueType
LARGENIPARTS	defs.h	218;"	d
LD	Makefile	/^LD = $(CC) -L. $/;"	m
LTERM	defs.h	76;"	d
ListGraph	struct.h	/^typedef struct listgraphdef ListGraph;$/;"	t	typeref:struct:listgraphdef
ListInt	struct.h	/^typedef struct intlistdef ListInt;$/;"	t	typeref:struct:intlistdef
ListNodeType	struct.h	/^struct ListNodeType {$/;"	s
ListNodeType	struct.h	/^typedef struct ListNodeType ListNodeType;$/;"	t	typeref:struct:ListNodeType
ListWgt	struct.h	/^typedef struct wgtlistdef ListWgt;$/;"	t	typeref:struct:wgtlistdef
MAKECSR	macros.h	150;"	d
MALLOC_CHECK	macros.h	135;"	d
MALLOC_CHECK	macros.h	142;"	d
MATCH_HASH	defs.h	183;"	d
MATCH_HEM	defs.h	174;"	d
MATCH_HEMN	defs.h	181;"	d
MATCH_POWERLAW_FC	defs.h	184;"	d
MATCH_RM	defs.h	173;"	d
MATCH_SBHEM_INFNORM	defs.h	180;"	d
MATCH_SBHEM_ONENORM	defs.h	179;"	d
MATCH_SHEBM_INFNORM	defs.h	178;"	d
MATCH_SHEBM_ONENORM	defs.h	177;"	d
MATCH_SHEM	defs.h	175;"	d
MATCH_SHEMKWAY	defs.h	176;"	d
MATCH_SHEMN	defs.h	182;"	d
MATCH_UNSPECIFIED	defs.h	185;"	d
MAXIDX	struct.h	94;"	d
MAXLINE	defs.h	74;"	d
MAXNCON	defs.h	78;"	d
MAXNOBJ	defs.h	79;"	d
MCCoarsen2Way	rename.h	216;"	d
MCGreedy_KWayEdgeBalanceHorizontal	rename.h	284;"	d
MCHMlevelEdgeBisection	rename.h	323;"	d
MCHMlevelRecursiveBisection	rename.h	321;"	d
MCMatch_HEM	rename.h	303;"	d
MCMatch_RM	rename.h	302;"	d
MCMatch_SBHEM	rename.h	306;"	d
MCMatch_SHEBM	rename.h	305;"	d
MCMatch_SHEM	rename.h	304;"	d
MCMlevelEdgeBisection	rename.h	322;"	d
MCMlevelKWayPartitioning	rename.h	279;"	d
MCMlevelRecursiveBisection	rename.h	320;"	d
MCRandom_KWayEdgeRefineHorizontal	rename.h	283;"	d
MLMCL_PRUNE_A	defs.h	100;"	d
MLMCL_PRUNE_B	defs.h	101;"	d
MMDOrder	rename.h	358;"	d
MMDSWITCH	defs.h	229;"	d
MTHRESH	myqsort.c	77;"	d	file:
MatchTmr	struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
Match_HEM	match.c	/^void Match_HEM(CtrlType *ctrl, GraphType *graph)$/;"	f
Match_HEM	rename.h	200;"	d
Match_RM	match.c	/^void Match_RM(CtrlType *ctrl, GraphType *graph)$/;"	f
Match_RM	rename.h	198;"	d
Match_RM_NVW	match.c	/^void Match_RM_NVW(CtrlType *ctrl, GraphType *graph)$/;"	f
Match_RM_NVW	rename.h	199;"	d
Match_SHEM	match.c	/^void Match_SHEM(CtrlType *ctrl, GraphType *graph)$/;"	f
Match_SHEM	rename.h	201;"	d
Matrix	struct.h	/^typedef struct matrixdef Matrix;$/;"	t	typeref:struct:matrixdef
McKMETIS_CTYPE	defs.h	151;"	d
McKMETIS_DBGLVL	defs.h	154;"	d
McKMETIS_ITYPE	defs.h	152;"	d
McKMETIS_RTYPE	defs.h	153;"	d
McPMETIS_CTYPE	defs.h	145;"	d
McPMETIS_DBGLVL	defs.h	148;"	d
McPMETIS_ITYPE	defs.h	146;"	d
McPMETIS_RTYPE	defs.h	147;"	d
MinCover	rename.h	255;"	d
MinCover_Augment	rename.h	256;"	d
MinCover_ColDFS	rename.h	258;"	d
MinCover_Decompose	rename.h	257;"	d
MinCover_RowDFS	rename.h	259;"	d
MlevelEdgeBisection	rename.h	368;"	d
MlevelKWayPartitioning	rename.h	151;"	d
MlevelNestedDissection	rename.h	353;"	d
MlevelNestedDissectionCC	rename.h	354;"	d
MlevelNestedDissectionP	rename.h	363;"	d
MlevelNodeBisection	rename.h	356;"	d
MlevelNodeBisectionMultiple	rename.h	355;"	d
MlevelRecursiveBisection	rename.h	367;"	d
MlevelVolKWayPartitioning	rename.h	155;"	d
MocAllocate2WayPartitionMemory	rename.h	328;"	d
MocAllocateKWayPartitionMemory	rename.h	295;"	d
MocBalance2Way	rename.h	205;"	d
MocBalance2Way2	rename.h	210;"	d
MocCompute2WayPartitionParams	rename.h	329;"	d
MocComputeKWayBalanceBoundary	rename.h	298;"	d
MocComputeKWayPartitionParams	rename.h	296;"	d
MocFM_2WayEdgeRefine	rename.h	241;"	d
MocFM_2WayEdgeRefine2	rename.h	249;"	d
MocGeneral2WayBalance	rename.h	206;"	d
MocGeneral2WayBalance2	rename.h	211;"	d
MocGrowBisection	rename.h	264;"	d
MocGrowBisection2	rename.h	272;"	d
MocGrowBisectionNew2	rename.h	273;"	d
MocInit2WayBalance	rename.h	266;"	d
MocInit2WayBalance2	rename.h	274;"	d
MocInit2WayPartition	rename.h	263;"	d
MocInit2WayPartition2	rename.h	271;"	d
MocIsHBalanced	rename.h	288;"	d
MocProject2WayPartition	rename.h	330;"	d
MocProjectKWayPartition	rename.h	297;"	d
MocRandomBisection	rename.h	265;"	d
MocRefine2Way	rename.h	327;"	d
MocRefine2Way2	rename.h	334;"	d
MocRefineKWayHorizontal	rename.h	294;"	d
MoveGroup	rename.h	428;"	d
MoveGroupMConn	rename.h	426;"	d
NEG_GAINSPAN	defs.h	82;"	d
NGR_PASSES	defs.h	215;"	d
NLGR_PASSES	defs.h	216;"	d
NORM_BC	defs.h	104;"	d
NORM_CC	defs.h	105;"	d
NRInfoType	struct.h	/^typedef struct nrinfodef NRInfoType;$/;"	t	typeref:struct:nrinfodef
OBJS	Makefile	/^OBJS = coarsen.o match.o ccgraph.o memory.o \\$/;"	m
OEMETIS_CTYPE	defs.h	130;"	d
OEMETIS_DBGLVL	defs.h	133;"	d
OEMETIS_ITYPE	defs.h	131;"	d
OEMETIS_RTYPE	defs.h	132;"	d
OFLAG_CCMP	defs.h	97;"	d
OFLAG_COMPRESS	defs.h	96;"	d
ONMETIS_CTYPE	defs.h	136;"	d
ONMETIS_DBGLVL	defs.h	139;"	d
ONMETIS_ITYPE	defs.h	137;"	d
ONMETIS_NSEPS	defs.h	142;"	d
ONMETIS_OFLAGS	defs.h	140;"	d
ONMETIS_PFACTOR	defs.h	141;"	d
ONMETIS_RTYPE	defs.h	138;"	d
OPTION_CTYPE	defs.h	88;"	d
OPTION_DBGLVL	defs.h	91;"	d
OPTION_ITYPE	defs.h	89;"	d
OPTION_NSEPS	defs.h	94;"	d
OPTION_OFLAGS	defs.h	92;"	d
OPTION_PFACTOR	defs.h	93;"	d
OPTION_PTYPE	defs.h	87;"	d
OPTION_RTYPE	defs.h	90;"	d
OP_KMETIS	defs.h	165;"	d
OP_KVMETIS	defs.h	169;"	d
OP_OEMETIS	defs.h	166;"	d
OP_ONMETIS	defs.h	167;"	d
OP_ONWMETIS	defs.h	168;"	d
OP_PMETIS	defs.h	164;"	d
OR	macros.h	92;"	d
ORDER_UNBALANCE_FRACTION	defs.h	227;"	d
Options	struct.h	/^typedef struct optionsdef Options;$/;"	t	typeref:struct:optionsdef
PLUS_GAINSPAN	defs.h	81;"	d
PMETIS_CTYPE	defs.h	118;"	d
PMETIS_DBGLVL	defs.h	121;"	d
PMETIS_ITYPE	defs.h	119;"	d
PMETIS_RTYPE	defs.h	120;"	d
PMPLUSPMT	defs.h	108;"	d
PQueueDelete	rename.h	378;"	d
PQueueFree	rename.h	376;"	d
PQueueGetMax	rename.h	381;"	d
PQueueInit	rename.h	374;"	d
PQueueInsert	rename.h	377;"	d
PQueueReset	rename.h	375;"	d
PQueueSeeMax	rename.h	382;"	d
PQueueType	struct.h	/^struct PQueueType {$/;"	s
PQueueType	struct.h	/^typedef struct PQueueType PQueueType;$/;"	t	typeref:struct:PQueueType
PQueueUpdate	rename.h	379;"	d
PQueueUpdateUp	rename.h	380;"	d
PageRankOptions	struct.h	/^typedef struct pagerankOptionsDef PageRankOptions;$/;"	t	typeref:struct:pagerankOptionsDef
ParallelQSort	util.c	/^void ParallelQSort(idxtype *a, wgttype *b, int start, int end)$/;"	f
ParallelQSortFloatsInts	util.c	/^void ParallelQSortFloatsInts(wgttype *a, idxtype *b, int start,$/;"	f
ParallelQSortInts	util.c	/^void ParallelQSortInts(idxtype *a, idxtype *b, int start, int end)$/;"	f
ParallelQSortIntsUsingScores	util.c	/^void ParallelQSortIntsUsingScores(idxtype *a, idxtype *b, idxtype$/;"	f
ParallelQSortLongs	util.c	/^void ParallelQSortLongs(long *a, wgttype *b, int start, int end)$/;"	f
ParallelRandomPartition	util.c	/^int ParallelRandomPartition(idxtype* a, wgttype* b, int start,$/;"	f
ParallelRandomPartitionFloatsInts	util.c	/^int ParallelRandomPartitionFloatsInts(wgttype* a, idxtype* b, int start,$/;"	f
ParallelRandomPartitionInts	util.c	/^int ParallelRandomPartitionInts(idxtype* a, idxtype* b, int start,$/;"	f
ParallelRandomPartitionIntsUsingScores	util.c	/^int ParallelRandomPartitionIntsUsingScores(idxtype* a, idxtype*$/;"	f
ParallelRandomPartitionLongs	util.c	/^int ParallelRandomPartitionLongs(long* a, wgttype* b, int start,$/;"	f
PrintSubDomainGraph	rename.h	423;"	d
PrintTimers	rename.h	433;"	d
PrintTimers	util.c	/^void PrintTimers(CtrlType *ctrl)$/;"	f
Project2WayNodePartition	rename.h	411;"	d
Project2WayPartition	rename.h	390;"	d
ProjectKWayPartition	rename.h	168;"	d
ProjectTmr	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
ProjectVolKWayPartition	rename.h	192;"	d
PruneGraph	rename.h	98;"	d
QSortIntsUsingInts	util.c	/^void QSortIntsUsingInts(idxtype *a, idxtype *scores, int start,$/;"	f
RInfoType	struct.h	/^typedef struct rinfodef RInfoType;$/;"	t	typeref:struct:rinfodef
RTYPE_FM	defs.h	193;"	d
RTYPE_KWAYGREEDY	defs.h	200;"	d
RTYPE_KWAYRANDOM	defs.h	199;"	d
RTYPE_KWAYRANDOM_MCONN	defs.h	201;"	d
RTYPE_SEP1SIDED	defs.h	205;"	d
RTYPE_SEP2SIDED	defs.h	204;"	d
RType	struct.h	/^  int RType;			\/* The type of refinement *\/$/;"	m	struct:controldef
RandomBisection	rename.h	147;"	d
RandomInRange	macros.h	79;"	d
RandomInRange	macros.h	82;"	d
RandomInRangeFast	macros.h	80;"	d
RandomInRangeFast	macros.h	83;"	d
RandomPartition	util.c	/^int RandomPartition(wgttype* a, int start, int end)$/;"	f
RandomPartitionInts	util.c	/^int RandomPartitionInts(idxtype* a, int start, int end)$/;"	f
RandomPartitionIntsUsingInts	util.c	/^int RandomPartitionIntsUsingInts(idxtype* a, const idxtype *scores,$/;"	f
RandomPermute	rename.h	469;"	d
RandomPermute	util.c	/^void RandomPermute(int n, idxtype *p, int flag)$/;"	f
RandomPermuteWgttype	util.c	/^void RandomPermuteWgttype(int n, wgttype *p, int flag)$/;"	f
RandomSelect	util.c	/^wgttype RandomSelect(wgttype *a, int start, int end, int i)$/;"	f
RandomSelectInts	util.c	/^idxtype RandomSelectInts(idxtype *a, int start, int end, int i)$/;"	f
Random_KWayEdgeRefine	rename.h	159;"	d
Random_KWayEdgeRefineMConn	rename.h	421;"	d
Random_KWayVolRefine	rename.h	175;"	d
Random_KWayVolRefineMConn	rename.h	176;"	d
RandomizeGraph	rename.h	135;"	d
ReAdjustMemory	ccgraph.c	/^void ReAdjustMemory(GraphType *graph, GraphType *cgraph, int dovsize) $/;"	f
ReAdjustMemory	rename.h	89;"	d
ReadGraph	io.c	/^void ReadGraph(GraphType *graph, const char *filename, int *wgtflag,$/;"	f
ReadMatrix	io.c	/^void ReadMatrix(Matrix *m, char *filename, wgttype threshold)$/;"	f
ReadMesh	io.c	/^idxtype *ReadMesh(const char *filename, int *ne, int *nn, int *etype)$/;"	f
RefTmr	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
Refine2Way	rename.h	387;"	d
Refine2WayNode	rename.h	408;"	d
RefineKWay	rename.h	165;"	d
RefineVolKWay	rename.h	188;"	d
SMALLNIPARTS	defs.h	219;"	d
SWAP	macros.h	95;"	d
SelectQueue	rename.h	242;"	d
SelectQueue2	rename.h	250;"	d
SelectQueue3	rename.h	212;"	d
SelectQueueOneWay2	rename.h	275;"	d
SelectQueueoneWay	rename.h	267;"	d
SepTmr	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
SetUpCoarseGraph	ccgraph.c	/^GraphType *SetUpCoarseGraph(GraphType *graph, int cnvtxs, int dovsize)$/;"	f
SetUpCoarseGraph	rename.h	88;"	d
SetUpGraph	rename.h	131;"	d
SetUpGraph2	rename.h	133;"	d
SetUpGraphKway	rename.h	132;"	d
SetUpSplitGraph	rename.h	370;"	d
SplitGraphOrder	rename.h	357;"	d
SplitGraphOrderCC	rename.h	359;"	d
SplitGraphPart	rename.h	369;"	d
SplitTmr	struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
TETDUALMETIS	rename.h	233;"	d
TETNODALMETIS	rename.h	236;"	d
THRESH	myqsort.c	76;"	d	file:
TRIDUALMETIS	rename.h	232;"	d
TRINODALMETIS	rename.h	235;"	d
TotalTmr	struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
UInt32	struct.h	/^typedef unsigned int UInt32;$/;"	t
UNBALANCE_FRACTION	defs.h	223;"	d
UNMATCHED	defs.h	211;"	d
UncoarsenTmr	struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
VEDegreeType	struct.h	/^typedef struct vedegreedef VEDegreeType;$/;"	t	typeref:struct:vedegreedef
VPInfoType	struct.h	/^typedef struct vpwgtdef VPInfoType;$/;"	t	typeref:struct:vpwgtdef
VRInfoType	struct.h	/^typedef struct vrinfodef VRInfoType;$/;"	t	typeref:struct:vrinfodef
VolSetUpGraph	rename.h	134;"	d
WGTTYPE_FLOAT	struct.h	86;"	d
WorkSpaceType	struct.h	/^typedef struct workspacedef WorkSpaceType;$/;"	t	typeref:struct:workspacedef
WriteGraph	io.c	/^void WriteGraph(const char *filename, int nvtxs, idxtype *xadj, idxtype *adjncy)$/;"	f
WriteGraphWithWts	io.c	/^void WriteGraphWithWts(const char *filename, int nvtxs, idxtype *xadj,$/;"	f
WriteMappedTxtGraphWithWts	io.c	/^void WriteMappedTxtGraphWithWts(const char *filename, int fullNvtxs, $/;"	f
WriteMatrix	io.c	/^void WriteMatrix(const char *filename, int nvtxs, idxtype *xadj,$/;"	f
WriteMeshPartition	io.c	/^void WriteMeshPartition(const char *fname, int nparts, int ne, idxtype *epart, int nn, idxtype *npart)$/;"	f
WriteMocGraph	io.c	/^void WriteMocGraph(GraphType *graph)$/;"	f
WritePartition	io.c	/^void WritePartition(const char *fname, idxtype *part, int n, int nparts)$/;"	f
WritePermutation	io.c	/^void WritePermutation(const char *fname, idxtype *iperm, int n)$/;"	f
WriteRMap	io.c	/^void WriteRMap(const char *fname, idxtype *map, int n)$/;"	f
WriteTxtGraph	io.c	/^void WriteTxtGraph(const char *filename, int nvtxs, idxtype *xadj, idxtype *adjncy)$/;"	f
WspaceAvail	memory.c	/^int WspaceAvail(CtrlType *ctrl)$/;"	f
WspaceAvail	rename.h	222;"	d
XOR	macros.h	93;"	d
add	mclbase.c	/^Matrix* add(Matrix* M0, Matrix* M1)$/;"	f
addSelfLoops	mclutils.c	/^Matrix* addSelfLoops(Matrix* M)$/;"	f
addToList	merge.c	/^void addToList(ListInt *l, int a)$/;"	f
addToList	merge.c	/^void addToList(ListWgt *l, int a)$/;"	f
adjLists	struct.h	/^	ListInt* adjLists;$/;"	m	struct:listgraphdef
adjncy	struct.h	/^	idxtype *xadj, *adjncy, *adjwgt;$/;"	m	struct:threadData
adjncy	struct.h	/^	idxtype* adjncy;$/;"	m	struct:matrixdef
adjncy	struct.h	/^  idxtype *adjncy;		\/* Array that stores the adjacency lists of nvtxs *\/$/;"	m	struct:graphdef
adjwgt	struct.h	/^	idxtype *xadj, *adjncy, *adjwgt;$/;"	m	struct:threadData
adjwgt	struct.h	/^	wgttype* adjwgt; \/* array that stores weights of the$/;"	m	struct:matrixdef
adjwgt	struct.h	/^  idxtype *adjwgt;		\/* Array that stores the weights of the adjacency lists *\/$/;"	m	struct:graphdef
adjwgtsum	struct.h	/^	wgttype* adjwgtsum; \/* sum of adjacency weights of each node,$/;"	m	struct:matrixdef
adjwgtsum	struct.h	/^  idxtype *adjwgtsum;		\/* The sum of the adjacency weight of each vertex *\/$/;"	m	struct:graphdef
allInOneStep	mclbase.c	/^Matrix* allInOneStep(Matrix* flows, Matrix* input_adj, idxtype*$/;"	f
allocListGraph	merge.c	/^ListGraph* allocListGraph(int nvtxs, int wgtflag, int$/;"	f
allocListInt	merge.c	/^void allocListInt(ListInt *l, int initSize, int increment)$/;"	f
allocListWgt	merge.c	/^void allocListWgt(ListWgt *l, int initSize, int increment)$/;"	f
allocMatrix	mclutils.c	/^Matrix* allocMatrix(int nvtxs, int nedges, int allocSum, int$/;"	f
allocSize	struct.h	/^	int allocSize;$/;"	m	struct:intlistdef
allocSize	struct.h	/^	int allocSize;$/;"	m	struct:wgtlistdef
alpha	struct.h	/^	wgttype alpha; \/\/ random jump probability.$/;"	m	struct:pagerankOptionsDef
amax	macros.h	88;"	d
amin	macros.h	89;"	d
assignClustersToHubs	util.c	/^void assignClustersToHubs(idxtype* indices, idxtype* map, int n,$/;"	f
attractors	struct.h	/^	idxtype* attractors; \/* the row with the maximum weight in a$/;"	m	struct:matrixdef
auxcore	struct.h	/^  idxtype *auxcore;			\/* This points to the memory of the edegrees *\/$/;"	m	struct:workspacedef
bcWeight	struct.h	/^	wgttype bcWeight;$/;"	m	struct:dirToUndirOptionsDef
blockSize	struct.h	/^	int blockSize;$/;"	m	struct:dirToUndirOptionsDef
bndind	struct.h	/^  idxtype *bndptr, *bndind;$/;"	m	struct:graphdef
bndptr	struct.h	/^  idxtype *bndptr, *bndind;$/;"	m	struct:graphdef
bsearch_insertPos	util.c	/^int bsearch_insertPos(idxtype *a, idxtype key, int start, int end)$/;"	f
buckets	struct.h	/^  ListNodeType **buckets;$/;"	m	struct:PQueueType
calculateMaxAndSum	mclbase.c	/^void calculateMaxAndSum(Matrix* a)$/;"	f
ccore	struct.h	/^  int maxcore, ccore;$/;"	m	struct:workspacedef
cdegree	struct.h	/^  int cdegree;$/;"	m	struct:workspacedef
changeAdjMatrix	rmcl.c	/^Matrix* changeAdjMatrix(Matrix* flows, Matrix* adj, idxtype*$/;"	f
changeBetweenMatrices	mclbase.c	/^void changeBetweenMatrices(Matrix* M0, Matrix* M1, wgttype* c)$/;"	f
charsum	rename.h	461;"	d
charsum	util.c	/^int charsum(int n, const char *x)$/;"	f
checksums	mclbase.c	/^void checksums(Matrix* M)$/;"	f
cleartimer	macros.h	111;"	d
cmap	struct.h	/^  idxtype *cmap;$/;"	m	struct:graphdef
coarsenTo	struct.h	/^	int coarsenTo;$/;"	m	struct:optionsdef
coarser	struct.h	/^  struct graphdef *coarser, *finer;$/;"	m	struct:graphdef	typeref:struct:graphdef::graphdef
compSizeDistribution	io.c	/^idxtype* compSizeDistribution(GraphType* graph, int$/;"	f
compareints	mclbase.c	/^int compareints(const void * a, const void * b)$/;"	f
comparewgttypes	mclbase.c	/^int comparewgttypes(const void * a, const void * b)$/;"	f
computeCutAndVol	metrics.c	/^void computeCutAndVol(GraphType* graph, idxtype* members, int$/;"	f
computeThreshold	mclbase.c	/^wgttype computeThreshold(wgttype avg, wgttype max)$/;"	f
controldef	struct.h	/^struct controldef {$/;"	s
convergeThreshold	struct.h	/^	wgttype convergeThreshold;$/;"	m	struct:pagerankOptionsDef
conversionMethod	struct.h	/^	int conversionMethod;$/;"	m	struct:dirToUndirOptionsDef
convertMetisOutputToClusterLists	merge.c	/^idxtype* convertMetisOutputToClusterLists(const idxtype* part, int$/;"	f
copyListInt	merge.c	/^void copyListInt(ListInt *dest, ListInt *src)$/;"	f
copyListWgt	merge.c	/^void copyListWgt(ListWgt *dest, ListWgt *src)$/;"	f
core	struct.h	/^  idxtype *core;			\/* Where pairs, indices, and degrees are coming from *\/$/;"	m	struct:workspacedef
createClusterGraph	merge.c	/^ListGraph* createClusterGraph(const idxtype *part, int nparts,$/;"	f
currentSize	struct.h	/^	int currentSize;$/;"	m	struct:matrixdef
dbglvl	struct.h	/^  int dbglvl;			\/* Controls the debuging output of the program *\/$/;"	m	struct:controldef
dfTraversal	util.c	/^void dfTraversal(GraphType *graph, idxtype root, idxtype* visited, int* nVisited)$/;"	f
dfTraversalMatrix	util.c	/^void dfTraversalMatrix(Matrix *graph, idxtype root, idxtype*$/;"	f
diffTwoColumns	mclbase.c	/^wgttype diffTwoColumns(Matrix *flows, int col1, int col2)$/;"	f
dirToUndirOptionsDef	struct.h	/^struct dirToUndirOptionsDef{$/;"	s
dpr_threshold	struct.h	/^	float dpr_threshold;$/;"	m	struct:optionsdef
dprmcl	rmcl.c	/^Matrix* dprmcl(Matrix* flows, Matrix* adj, GraphType* graph, $/;"	f
dprmclWrapper	rmcl.c	/^void dprmclWrapper(int* nvtxs, idxtype* xadj, idxtype* adjncy, idxtype$/;"	f
dumpMatrix	mclutils.c	/^void dumpMatrix(Matrix* a)$/;"	f
dump_graph	mclutils.c	/^void dump_graph(GraphType *graph)$/;"	f
ed	struct.h	/^  idxtype *id, *ed;$/;"	m	struct:graphdef
ed	struct.h	/^  idxtype ed, ned;$/;"	m	struct:vedegreedef
ed	struct.h	/^  idxtype ed;$/;"	m	struct:edegreedef
ed	struct.h	/^ int id, ed, nid;            	\/* ID\/ED of nodes *\/$/;"	m	struct:vrinfodef
ed	struct.h	/^ int id, ed;            	\/* ID\/ED of nodes *\/$/;"	m	struct:rinfodef
edegreedef	struct.h	/^struct edegreedef {$/;"	s
edegrees	struct.h	/^  EDegreeType *edegrees;$/;"	m	struct:workspacedef
edegrees	struct.h	/^ EDegreeType *edegrees;     	\/* List of edges *\/$/;"	m	struct:rinfodef
edegrees	struct.h	/^ VEDegreeType *edegrees;     	\/* List of edges *\/$/;"	m	struct:vrinfodef
edegrees	struct.h	/^ idxtype edegrees[2];  $/;"	m	struct:nrinfodef
errexit	rename.h	438;"	d
errexit	util.c	/^void errexit(char *f_str,...)$/;"	f
exact	struct.h	/^	int exact;$/;"	m	struct:optionsdef
exactPrune	mclbase.c	/^wgttype exactPrune(int *n, idxtype* adjncy, wgttype* adjwgt,$/;"	f
exactPruneGraph	mclbase.c	/^void exactPruneGraph(GraphType* graph, int l, idxtype thresh )$/;"	f
exactPruneMatrix	mclbase.c	/^void exactPruneMatrix(Matrix* M, int l)$/;"	f
expand	mclbase.c	/^Matrix* expand(Matrix* M, Matrix* M0)$/;"	f
expand_ht	mclbase.c	/^Matrix* expand_ht(Matrix* M, Matrix* M0, idxtype*$/;"	f
finer	struct.h	/^  struct graphdef *coarser, *finer;$/;"	m	struct:graphdef	typeref:struct:graphdef::
fmalloc	macros.h	127;"	d
fmalloc	rename.h	443;"	d
fmalloc	util.c	/^float *fmalloc(int n, const char *msg)$/;"	f
freeMatrix	mclutils.c	/^void freeMatrix(Matrix* a)$/;"	f
fwspacefree	memory.c	/^void fwspacefree(CtrlType *ctrl, int n)$/;"	f
fwspacemalloc	memory.c	/^float *fwspacemalloc(CtrlType *ctrl, int n)$/;"	f
fwspacemalloc	rename.h	225;"	d
gamma	struct.h	/^	float gamma;$/;"	m	struct:optionsdef
gdata	struct.h	/^  idxtype *gdata, *rdata;	\/* Memory pools for graph and refinement data.$/;"	m	struct:graphdef
genmmd	rename.h	312;"	d
getAttractorsForAll	mclutils.c	/^void getAttractorsForAll(Matrix* M)$/;"	f
getCutGraph	subgraphs.c	/^GraphType* getCutGraph(GraphType* graph, idxtype* indices, $/;"	f
getDegreeHistogram	metrics.c	/^idxtype* getDegreeHistogram(GraphType* graph, int* maxDegree, int$/;"	f
getDprAdjMatrix	mclbase.c	/^Matrix* getDprAdjMatrix(Matrix* flows, Matrix* adj, idxtype*$/;"	f
getLogBin	metrics.c	/^int getLogBin(int a)$/;"	f
getNodesToComponentMap	io.c	/^idxtype* getNodesToComponentMap(Matrix* graph1, int *numComponents,$/;"	f
getPermutedGraph	mclutils.c	/^void getPermutedGraph(idxtype* perm, idxtype* revPerm, int nvtxs, $/;"	f
getRowSums	mclbase.c	/^wgttype* getRowSums(Matrix* a)$/;"	f
getSubgraph	subgraphs.c	/^void getSubgraph(GraphType *graph, idxtype* newIds, int new_nvtxs, int$/;"	f
getTranspose	mclbase.c	/^Matrix* getTranspose(Matrix* M)$/;"	f
getTranspose2	mclbase.c	/^Matrix* getTranspose2(Matrix* M)$/;"	f
getWeightsHistogram	metrics.c	/^idxtype* getWeightsHistogram(GraphType* graph, int* maxWeight, int$/;"	f
gettimer	macros.h	114;"	d
globallySampleEdges	subgraphs.c	/^void globallySampleEdges(int nvtxs, int nedges, idxtype* xadj, idxtype*$/;"	f
graphdef	struct.h	/^struct graphdef {$/;"	s
gv	struct.h	/^  idxtype gv;$/;"	m	struct:vedegreedef
gv	struct.h	/^ int gv;            		\/* IV\/EV of nodes *\/$/;"	m	struct:vrinfodef
hashes	struct.h	/^	idxtype *hashes;$/;"	m	struct:hashtabledef
hashtabledef	struct.h	/^struct hashtabledef$/;"	s
heap	struct.h	/^  KeyValueType *heap;$/;"	m	struct:PQueueType
histogram	metrics.c	/^idxtype* histogram(idxtype* values, int n, int numUnique)$/;"	f
hubPct	struct.h	/^	float hubPct;$/;"	m	struct:optionsdef
hubRemoval	struct.h	/^	int hubRemoval;$/;"	m	struct:optionsdef
iamax	rename.h	451;"	d
iamax	util.c	/^int iamax(int n, int *x)$/;"	f
id	struct.h	/^  idxtype *id, *ed;$/;"	m	struct:graphdef
id	struct.h	/^  int id;                       	\/* The id value of the node *\/$/;"	m	struct:ListNodeType
id	struct.h	/^ int id, ed, nid;            	\/* ID\/ED of nodes *\/$/;"	m	struct:vrinfodef
id	struct.h	/^ int id, ed;            	\/* ID\/ED of nodes *\/$/;"	m	struct:rinfodef
idxadd	rename.h	460;"	d
idxadd	util.c	/^void idxadd(int n, idxtype *x, idxtype *y)$/;"	f
idxamax	rename.h	452;"	d
idxamax	util.c	/^int idxamax(int n, idxtype *x)$/;"	f
idxamax_strd	rename.h	453;"	d
idxamax_strd	util.c	/^int idxamax_strd(int n, idxtype *x, int incx)$/;"	f
idxamin	rename.h	456;"	d
idxamin	util.c	/^int idxamin(int n, idxtype *x)$/;"	f
idxcopy	macros.h	103;"	d
idxmalloc	macros.h	128;"	d
idxmalloc	rename.h	442;"	d
idxmalloc	util.c	/^idxtype *idxmalloc(int n, const char *msg)$/;"	f
idxset	rename.h	449;"	d
idxset	util.c	/^idxtype *idxset(int n, idxtype val, idxtype *x)$/;"	f
idxsmalloc	macros.h	130;"	d
idxsmalloc	rename.h	445;"	d
idxsmalloc	util.c	/^idxtype *idxsmalloc(int n, idxtype ival, const char *msg)$/;"	f
idxsum	rename.h	458;"	d
idxsum	util.c	/^int idxsum(int n, idxtype *x)$/;"	f
idxsum_strd	rename.h	459;"	d
idxsum_strd	util.c	/^int idxsum_strd(int n, idxtype *x, int incx)$/;"	f
idxtype	struct.h	/^typedef int idxtype;$/;"	t
idxtype	struct.h	/^typedef short idxtype;$/;"	t
idxwspacefree	memory.c	/^void idxwspacefree(CtrlType *ctrl, int n)$/;"	f
idxwspacefree	rename.h	224;"	d
idxwspacemalloc	memory.c	/^idxtype *idxwspacemalloc(CtrlType *ctrl, int n)$/;"	f
idxwspacemalloc	rename.h	223;"	d
iidxsort	myqsort.c	/^void iidxsort(int n, idxtype *base)$/;"	f
iidxsort	rename.h	346;"	d
iintsort	myqsort.c	/^void iintsort(int n, int *base)$/;"	f
iintsort	rename.h	347;"	d
iiqst	myqsort.c	/^static void iiqst(int *base, int *max)$/;"	f	file:
ikeysort	myqsort.c	/^void ikeysort(int n, KeyValueType *base)$/;"	f
ikeysort	rename.h	348;"	d
ikeyvalsort	myqsort.c	/^void ikeyvalsort(int n, KeyValueType *base)$/;"	f
ikeyvalsort	rename.h	349;"	d
imalloc	macros.h	126;"	d
imalloc	rename.h	441;"	d
imalloc	util.c	/^int *imalloc(int n, const char *msg)$/;"	f
imax	struct.h	/^  int imax[2][MAXNCON];$/;"	m	struct:vpwgtdef
increment	struct.h	/^	int increment;$/;"	m	struct:intlistdef
increment	struct.h	/^	int increment;$/;"	m	struct:wgtlistdef
inflate	mclbase.c	/^void inflate(Matrix* a, float gamma)$/;"	f
initOptions	util.c	/^void initOptions(Options* opt)$/;"	f
insertLastElement	mclbase.c	/^int insertLastElement(idxtype* adjncy, wgttype* adjwgt, int count)$/;"	f
intlistdef	struct.h	/^struct intlistdef{$/;"	s
invDegreeType	struct.h	/^	int invDegreeType;$/;"	m	struct:dirToUndirOptionsDef
isConverged	mclutils.c	/^int isConverged(idxtype* oldAttr, idxtype* newAttr, int n)$/;"	f
isConverged2	mclutils.c	/^int isConverged2(idxtype* oldAttr, idxtype* newAttr, int n)$/;"	f
isDirected	struct.h	/^  int isDirected; $/;"	m	struct:graphdef
isGraphConnected	io.c	/^int isGraphConnected(GraphType *graph)$/;"	f
isOrgGraph	struct.h	/^  int isOrgGraph; $/;"	m	struct:graphdef
iset	rename.h	448;"	d
iset	util.c	/^int *iset(int n, int val, int *x)$/;"	f
ismalloc	macros.h	129;"	d
ismalloc	rename.h	444;"	d
ismalloc	util.c	/^int *ismalloc(int n, int ival, const char *msg)$/;"	f
ispow2	rename.h	470;"	d
ispow2	util.c	/^int ispow2(int a)$/;"	f
isum	rename.h	462;"	d
isum	util.c	/^int isum(int n, int *x)$/;"	f
iter_per_level	struct.h	/^	int iter_per_level;$/;"	m	struct:optionsdef
k	struct.h	/^	int k;$/;"	m	struct:optionsdef
key	struct.h	/^  idxtype key;$/;"	m	struct:KeyValueType
keyiqst	myqsort.c	/^static void keyiqst(KeyValueType *base, KeyValueType *max)$/;"	f	file:
keyvaliqst	myqsort.c	/^static void keyvaliqst(KeyValueType *base, KeyValueType *max)$/;"	f	file:
l	struct.h	/^	idxtype* l;$/;"	m	struct:intlistdef
l	struct.h	/^	wgttype* l;$/;"	m	struct:wgtlistdef
label	struct.h	/^  idxtype *label;$/;"	m	struct:graphdef
length	struct.h	/^	int length;$/;"	m	struct:intlistdef
length	struct.h	/^	int length;$/;"	m	struct:wgtlistdef
listgraphdef	struct.h	/^struct listgraphdef{$/;"	s
locator	struct.h	/^  idxtype *locator;$/;"	m	struct:PQueueType
log2	rename.h	472;"	d
log2	util.c	/^int log2(int a)$/;"	f
lookForSingletons	util.c	/^idxtype* lookForSingletons(GraphType* graph, int* noOfSingletons)$/;"	f
mapIndices	util.c	/^void mapIndices(idxtype *indices, idxtype* map, int n, int npart)$/;"	f
mapPartition	metrics.c	/^int mapPartition(idxtype* part, idxtype nvtxs)$/;"	f
matchType	struct.h	/^	int matchType;$/;"	m	struct:optionsdef
matrixdef	struct.h	/^struct matrixdef{$/;"	s
max	struct.h	/^  float max[2][MAXNCON];$/;"	m	struct:vpwgtdef
max_iters	struct.h	/^	int max_iters;$/;"	m	struct:pagerankOptionsDef
maxcore	struct.h	/^  int maxcore, ccore;$/;"	m	struct:workspacedef
maxgain	struct.h	/^  int maxgain;$/;"	m	struct:PQueueType
maxnodes	struct.h	/^  int maxnodes;$/;"	m	struct:PQueueType
maxvwgt	struct.h	/^  int maxvwgt;			\/* The maximum allowed weight for a vertex *\/$/;"	m	struct:controldef
maxwgt	struct.h	/^	wgttype* maxwgt; \/* max wgt of each column, assigned only$/;"	m	struct:matrixdef
mergeBestClusters	merge.c	/^void mergeBestClusters(ListGraph *cg, idxtype* part_mapper, int$/;"	f
mergeLists	merge.c	/^ListInt* mergeLists(const ListInt* al1, const ListWgt* wl1, $/;"	f
mincut	struct.h	/^  int mincut, minvol;$/;"	m	struct:graphdef
minvol	struct.h	/^  int mincut, minvol;$/;"	m	struct:graphdef
mis_coarsenType	struct.h	/^	int mis_coarsenType;$/;"	m	struct:optionsdef
mis_projectFlow	mlmcl.c	/^Matrix* mis_projectFlow(Matrix* Mc, idxtype* rmap, int nvtxs)$/;"	f
mlmcl	mlmcl.c	/^void mlmcl(int* nvtxs, idxtype* xadj, idxtype* adjncy, idxtype$/;"	f
mlmclWithGraph	mlmcl.c	/^void mlmclWithGraph(GraphType *graph,idxtype* indices,Options opt)$/;"	f
mmdelm	rename.h	313;"	d
mmdint	rename.h	314;"	d
mmdnum	rename.h	315;"	d
mmdupd	rename.h	316;"	d
mustfree	struct.h	/^  int mustfree;$/;"	m	struct:PQueueType
my_AllocateWorkSpace	memory.c	/^void my_AllocateWorkSpace(CtrlType *ctrl, GraphType *graph )$/;"	f
my_CreateCoarseGraph	ccgraph.c	/^void my_CreateCoarseGraph(CtrlType *ctrl, GraphType *graph, int cnvtxs, idxtype *match, idxtype *perm)$/;"	f
my_Match_HEMN	match.c	/^void my_Match_HEMN(CtrlType *ctrl, GraphType *graph)$/;"	f
my_Match_PowerLaw_FC	match.c	/^void my_Match_PowerLaw_FC(CtrlType *ctrl, GraphType *graph)$/;"	f
my_Match_RM	match.c	/^void my_Match_RM(CtrlType *ctrl, GraphType *graph)$/;"	f
my_Match_SHEMN	match.c	/^void my_Match_SHEMN(CtrlType *ctrl, GraphType *graph)$/;"	f
my_SetUpCoarseGraph	ccgraph.c	/^GraphType* my_SetUpCoarseGraph(GraphType *graph, int cnvtxs)$/;"	f
my_SetUpGraph	graph.c	/^void my_SetUpGraph(GraphType *graph, int nvtxs, idxtype* xadj,$/;"	f
my_WriteMappedPartition	io.c	/^void my_WriteMappedPartition(const char *fname, idxtype *part, idxtype$/;"	f
my_WritePartition	io.c	/^void my_WritePartition(const char *fname, idxtype *part, int n, float gamma)$/;"	f
my_WritePartitionAddOne	io.c	/^void my_WritePartitionAddOne(const char *fname, idxtype *part, int n)$/;"	f
nbnd	struct.h	/^  int nbnd;$/;"	m	struct:graphdef
ncon	struct.h	/^  int ncon;			\/* The # of constrains *\/ $/;"	m	struct:graphdef
ncutify	struct.h	/^	int ncutify;$/;"	m	struct:optionsdef
ncutifyWeights	mclutils.c	/^void ncutifyWeights(Matrix* M, int hasWeightsAlready, int ncutify)$/;"	f
ndegrees	struct.h	/^ int ndegrees;          	\/* The number of different ext-degrees *\/$/;"	m	struct:rinfodef
ndegrees	struct.h	/^ int ndegrees;          	\/* The number of different ext-degrees *\/$/;"	m	struct:vrinfodef
ned	struct.h	/^  idxtype ed, ned;$/;"	m	struct:vedegreedef
nedges	struct.h	/^	int nedges;$/;"	m	struct:listgraphdef
nedges	struct.h	/^  int nvtxs, nedges;		\/* The # of vertices and edges in the graph *\/$/;"	m	struct:graphdef
next	struct.h	/^  struct ListNodeType *prev, *next;     \/* It's a doubly-linked list *\/$/;"	m	struct:ListNodeType	typeref:struct:ListNodeType::
ngainspan	struct.h	/^  int pgainspan, ngainspan;     \/* plus and negative gain span *\/$/;"	m	struct:PQueueType
nid	struct.h	/^ int id, ed, nid;            	\/* ID\/ED of nodes *\/$/;"	m	struct:vrinfodef
nmaxvwgt	struct.h	/^  float nmaxvwgt;		\/* The maximum allowed weight for a vertex for each constrain *\/$/;"	m	struct:controldef
nnodes	struct.h	/^  int nnodes;$/;"	m	struct:PQueueType
nnz	struct.h	/^	int nvtxs, nnz; \/* nnz stands for number of non-zero$/;"	m	struct:matrixdef
noOfUnique	mclutils.c	/^int noOfUnique(idxtype* attrs,int n, idxtype* hashtable)$/;"	f
nodes	struct.h	/^  ListNodeType *nodes;$/;"	m	struct:PQueueType
normalizeColumns	mclutils.c	/^void normalizeColumns(Matrix* M, int hasWeightsAlready, int$/;"	f
npwgts	struct.h	/^  float *npwgts;		\/* The normalized partition weights *\/$/;"	m	struct:graphdef
nrinfo	struct.h	/^  NRInfoType *nrinfo;$/;"	m	struct:graphdef
nrinfodef	struct.h	/^struct nrinfodef {$/;"	s
nseps	struct.h	/^  int nseps;			\/* The number of separators to be found during multiple bisections *\/$/;"	m	struct:controldef
numDescendants	struct.h	/^  idxtype *numDescendants;$/;"	m	struct:graphdef
numHashes	struct.h	/^	int numHashes;$/;"	m	struct:hashtabledef
numNodes	struct.h	/^	int numNodes;$/;"	m	struct:hashtabledef
numWithoutAttractors	mclutils.c	/^int numWithoutAttractors(Matrix* M)$/;"	f
num_last_iter	struct.h	/^	int num_last_iter;$/;"	m	struct:optionsdef
nvtxs	struct.h	/^	int nvtxs, nnz; \/* nnz stands for number of non-zero$/;"	m	struct:matrixdef
nvtxs	struct.h	/^	int nvtxs;$/;"	m	struct:listgraphdef
nvtxs	struct.h	/^	int nvtxs;$/;"	m	struct:threadData
nvtxs	struct.h	/^  int nvtxs, nedges;		\/* The # of vertices and edges in the graph *\/$/;"	m	struct:graphdef
nvwgt	struct.h	/^  float *nvwgt;			\/* Normalized vertex weights *\/$/;"	m	struct:graphdef
oflags	struct.h	/^  int oflags;$/;"	m	struct:controldef
optionsdef	struct.h	/^struct optionsdef{$/;"	s
optype	struct.h	/^  int optype;			\/* Type of operation *\/$/;"	m	struct:controldef
pagerank	struct.h	/^  wgttype *pagerank;$/;"	m	struct:graphdef
pagerankOptionsDef	struct.h	/^struct pagerankOptionsDef{$/;"	s
penalty_power	struct.h	/^	float penalty_power; \/\/ used in transformAdj$/;"	m	struct:optionsdef
permuteDegreeOrder	util.c	/^void permuteDegreeOrder(int n, idxtype *p, idxtype *xadj)$/;"	f
permuteRowsAndColumns	mclutils.c	/^Matrix* permuteRowsAndColumns(Matrix *M, idxtype* rowPerm, idxtype* colPerm)$/;"	f
permuteRowsAndColumns	mclutils.c	/^Matrix* permuteRowsAndColumns(Matrix* M, idxtype* perm)$/;"	f
pfactor	struct.h	/^  int pfactor;			\/* .1*prunning factor *\/$/;"	m	struct:controldef
pgainspan	struct.h	/^  int pgainspan, ngainspan;     \/* plus and negative gain span *\/$/;"	m	struct:PQueueType
pid	struct.h	/^  idxtype pid;$/;"	m	struct:edegreedef
pid	struct.h	/^  idxtype pid;$/;"	m	struct:vedegreedef
pmat	struct.h	/^  idxtype *pmat;			\/* An array of k^2 used for eliminating domain $/;"	m	struct:workspacedef
prev	struct.h	/^  struct ListNodeType *prev, *next;     \/* It's a doubly-linked list *\/$/;"	m	struct:ListNodeType	typeref:struct:ListNodeType::ListNodeType
printHistogram	io.c	/^void printHistogram(idxtype* hist, int maxDegree, FILE* fp)$/;"	f
printRow	mclutils.c	/^void printRow(Matrix *M, int row)$/;"	f
propagateFlow	mlmcl.c	/^Matrix* propagateFlow(Matrix* cm, GraphType* cgraph, GraphType*$/;"	f
pruneAndNormalize	mclbase.c	/^void pruneAndNormalize(Matrix* a, int exact, int k)$/;"	f
prunePercent	struct.h	/^	wgttype prunePercent;$/;"	m	struct:dirToUndirOptionsDef
pwgts	struct.h	/^  idxtype *where, *pwgts;$/;"	m	struct:graphdef
rdata	struct.h	/^  idxtype *gdata, *rdata;	\/* Memory pools for graph and refinement data.$/;"	m	struct:graphdef
readClustering	io.c	/^int readClustering(const char *filename, int *part, int nvtex){$/;"	f
readMemberships	io.c	/^void readMemberships( char *file, int numMemberships, idxtype$/;"	f
removeHubs	subgraphs.c	/^idxtype* removeHubs(GraphType *graph, int threshold, int wgtflag,$/;"	f
removeSelfLoops	mclutils.c	/^Matrix* removeSelfLoops(Matrix* M, int normalizeColumns)$/;"	f
removeSelfLoops	mclutils.c	/^void removeSelfLoops(GraphType* g)$/;"	f
ret	struct.h	/^	Matrix **ret;$/;"	m	struct:threadData
ret_adjncy	struct.h	/^	idxtype **ret_xadj, **ret_adjncy, **ret_adjwgt;$/;"	m	struct:threadData
ret_adjwgt	struct.h	/^	idxtype **ret_xadj, **ret_adjncy, **ret_adjwgt;$/;"	m	struct:threadData
ret_xadj	struct.h	/^	idxtype **ret_xadj, **ret_adjncy, **ret_adjwgt;$/;"	m	struct:threadData
rinfo	struct.h	/^  RInfoType *rinfo;$/;"	m	struct:graphdef
rinfodef	struct.h	/^struct rinfodef {$/;"	s
rmap	struct.h	/^	idxtype* rmap; \/* This is for mis_coarsen *\/$/;"	m	struct:matrixdef
rmap1	struct.h	/^  idxtype *rmap1;$/;"	m	struct:graphdef
rmap2	struct.h	/^  idxtype *rmap2;$/;"	m	struct:graphdef
samax	rename.h	454;"	d
samax	util.c	/^int samax(int n, float *x)$/;"	f
samax2	rename.h	455;"	d
samax2	util.c	/^int samax2(int n, float *x)$/;"	f
samin	rename.h	457;"	d
samin	util.c	/^int samin(int n, float *x)$/;"	f
saxpy	rename.h	468;"	d
saxpy	util.c	/^void saxpy(int n, float alpha, float *x, int incx, float *y, int incy)$/;"	f
scale	struct.h	/^	wgttype scale;$/;"	m	struct:dirToUndirOptionsDef
scopy	macros.h	102;"	d
sdot	rename.h	467;"	d
sdot	util.c	/^float sdot(int n, float *x, float *y)$/;"	f
seconds	rename.h	434;"	d
seconds	util.c	/^double seconds(void)$/;"	f
setupCanonicalMatrix	mclutils.c	/^Matrix* setupCanonicalMatrix(int nvtxs, int nedges, idxtype* xadj,$/;"	f
siqst	myqsort.c	/^static void siqst(idxtype *base, idxtype *max)$/;"	f	file:
sizeIncrement	struct.h	/^	int sizeIncrement;$/;"	m	struct:matrixdef
snorm2	rename.h	466;"	d
snorm2	util.c	/^float snorm2(int n, float *v)$/;"	f
sortAdjLists	mclutils.c	/^void sortAdjLists(int nvtxs, idxtype* xadj, idxtype* adjncy, wgttype* adjwgt)$/;"	f
sortedNodeIds	struct.h	/^	idxtype *sortedNodeIds; $/;"	m	struct:hashtabledef
sscale	rename.h	465;"	d
sscale	util.c	/^void sscale(int n, float alpha, float *x)$/;"	f
sset	rename.h	450;"	d
sset	util.c	/^float *sset(int n, float val, float *x)$/;"	f
ssum	rename.h	463;"	d
ssum	util.c	/^float ssum(int n, float *x)$/;"	f
ssum_strd	rename.h	464;"	d
ssum_strd	util.c	/^float ssum_strd(int n, float *x, int incx)$/;"	f
starttimer	macros.h	112;"	d
stdDeviation	metrics.c	/^float stdDeviation(idxtype* values, int n)$/;"	f
stoptimer	macros.h	113;"	d
swapidxtype	mclbase.c	/^void swapidxtype(idxtype* a, idxtype* b)$/;"	f
swapwgttype	mclbase.c	/^void swapwgttype(wgttype* a, wgttype* b)$/;"	f
testCoarsening	mclutils.c	/^void testCoarsening(int *nvtxs, idxtype *xadj, idxtype *adjncy,$/;"	f
threadData	struct.h	/^struct threadData {$/;"	s
threshPrune	mclbase.c	/^wgttype threshPrune(int *n, idxtype* adjncy, wgttype* adjwgt,$/;"	f
threshold	struct.h	/^	float threshold;$/;"	m	struct:threadData
threshold	struct.h	/^	wgttype threshold;$/;"	m	struct:dirToUndirOptionsDef
timer	struct.h	/^typedef double timer;$/;"	t
transformAdj	mclbase.c	/^Matrix* transformAdj(Matrix* flows, Matrix* input_adj, $/;"	f
transformAdj	struct.h	/^	int transformAdj;$/;"	m	struct:optionsdef
type	struct.h	/^  int type;                     \/* The type of the representation used *\/$/;"	m	struct:PQueueType
val	struct.h	/^  idxtype val;$/;"	m	struct:KeyValueType
vedegreedef	struct.h	/^struct vedegreedef {$/;"	s
vedegrees	struct.h	/^  VEDegreeType *vedegrees;$/;"	m	struct:workspacedef
vols	struct.h	/^	wgttype* vols; \/\/ volumes, i.e. sum of edge weights$/;"	m	struct:listgraphdef
vpwgtdef	struct.h	/^struct vpwgtdef {$/;"	s
vrinfo	struct.h	/^  VRInfoType *vrinfo;$/;"	m	struct:graphdef
vrinfodef	struct.h	/^struct vrinfodef {$/;"	s
vsize	struct.h	/^  idxtype *vsize;		\/* Vertex sizes for min-volume formulation *\/$/;"	m	struct:graphdef
vwgt	struct.h	/^  idxtype *vwgt;		\/* Vertex weights *\/$/;"	m	struct:graphdef
wgtLists	struct.h	/^	ListWgt* wgtLists;$/;"	m	struct:listgraphdef
wgtlistdef	struct.h	/^struct wgtlistdef{$/;"	s
wgtset	util.c	/^wgttype* wgtset(int n, wgttype val, wgttype *x)$/;"	f
wgttype	struct.h	/^typedef double wgttype;$/;"	t
wgttype	struct.h	/^typedef float wgttype;$/;"	t
where	struct.h	/^  idxtype *where, *pwgts;$/;"	m	struct:graphdef
workspacedef	struct.h	/^struct workspacedef {$/;"	s
wspace	struct.h	/^  WorkSpaceType wspace;		\/* Work Space Informations *\/$/;"	m	struct:controldef
xadj	struct.h	/^	idxtype *xadj, *adjncy, *adjwgt;$/;"	m	struct:threadData
xadj	struct.h	/^	idxtype* xadj; \/* xadj[i+1]-xadj[i] gives the number of$/;"	m	struct:matrixdef
xadj	struct.h	/^  idxtype *xadj;		\/* Pointers to the locally stored vertices *\/$/;"	m	struct:graphdef
