!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AND	Lib/macros.h	91;"	d
APLUSAT	Lib/defs.h	107;"	d
ASSERT	Lib/macros.h	182;"	d
ASSERT	Lib/macros.h	189;"	d
ASSERTP	Lib/macros.h	193;"	d
ASSERTP	Lib/macros.h	201;"	d
Allocate2WayNodePartitionMemory	Lib/rename.h	409;"	d
Allocate2WayPartitionMemory	Lib/rename.h	388;"	d
AllocateKWayPartitionMemory	Lib/rename.h	166;"	d
AllocateVolKWayPartitionMemory	Lib/rename.h	189;"	d
AllocateWorkSpace	Lib/memory.c	/^void AllocateWorkSpace(CtrlType *ctrl, GraphType *graph, int nparts)$/;"	f
AllocateWorkSpace	Lib/rename.h	220;"	d
AreAllBelow	Lib/rename.h	342;"	d
AreAllHVwgtsAbove	Lib/rename.h	286;"	d
AreAllHVwgtsBelow	Lib/rename.h	285;"	d
AreAllVwgtsAbove	Lib/rename.h	340;"	d
AreAllVwgtsBelow	Lib/rename.h	338;"	d
AreAllVwgtsBelowFast	Lib/rename.h	308;"	d
AreAnyVwgtsBelow	Lib/rename.h	339;"	d
AtimesATranspose	Lib/mclbase.c	/^Matrix* AtimesATranspose(Matrix* A, wgttype*$/;"	f
AtimesATransposeBlocking	Lib/mclbase.c	/^Matrix* AtimesATransposeBlocking(Matrix* A, wgttype* outerDiagonalFactor,$/;"	f
AuxTmr1	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr2	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr3	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr4	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr5	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr6	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
BCPLUSCC	Lib/defs.h	106;"	d
BINDIR	Programs/Makefile	/^BINDIR = ..$/;"	m
BNDDelete	Lib/macros.h	168;"	d
BNDInsert	Lib/macros.h	161;"	d
Balance2Way	Lib/rename.h	75;"	d
BetterBalance	Lib/rename.h	243;"	d
BetterVBalance	Lib/rename.h	307;"	d
Bnd2WayBalance	Lib/rename.h	76;"	d
BucketSortKeysInc	Lib/rename.h	81;"	d
BucketSortKeysInc	Lib/util.c	/^void BucketSortKeysInc(int n, int max, idxtype *keys, idxtype *tperm, idxtype *perm)$/;"	f
CFLAGS	Lib/Makefile	/^CFLAGS = $(COPTIONS) $(OPTFLAGS) $(INCLUDES)$/;"	m
CFLAGS	Programs/Makefile	/^CFLAGS = $(COPTIONS) $(OPTFLAGS) $(INCLUDES)$/;"	m
COARSEN_FRACTION	Lib/defs.h	221;"	d
COARSEN_FRACTION2	Lib/defs.h	222;"	d
COMPRESSION_FRACTION	Lib/defs.h	225;"	d
CType	Lib/struct.h	/^  int CType;			\/* The type of coarsening *\/$/;"	m	struct:controldef
Change2CNumbering	Lib/rename.h	121;"	d
Change2FNumbering	Lib/rename.h	122;"	d
Change2FNumbering2	Lib/rename.h	123;"	d
Change2FNumberingOrder	Lib/rename.h	124;"	d
ChangeMesh2CNumbering	Lib/rename.h	125;"	d
ChangeMesh2FNumbering	Lib/rename.h	126;"	d
ChangeMesh2FNumbering2	Lib/rename.h	127;"	d
CheckBnd	Lib/rename.h	103;"	d
CheckBnd2	Lib/rename.h	104;"	d
CheckGraph	Lib/io.c	/^int CheckGraph(GraphType *graph)$/;"	f
CheckHeap	Lib/rename.h	383;"	d
CheckNodeBnd	Lib/rename.h	105;"	d
CheckNodePartitionParams	Lib/rename.h	107;"	d
CheckRInfo	Lib/rename.h	106;"	d
CheckVolKWayPartitionParams	Lib/rename.h	182;"	d
Coarsen2Way	Lib/coarsen.c	/^GraphType *Coarsen2Way(CtrlType *ctrl, GraphType *graph)$/;"	f
Coarsen2Way	Lib/rename.h	93;"	d
CoarsenTmr	Lib/struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
CoarsenTo	Lib/struct.h	/^  int CoarsenTo;		\/* The # of vertices in the coarsest graph *\/$/;"	m	struct:controldef
CompressGraph	Lib/rename.h	97;"	d
Compute2WayHLoadImbalance	Lib/rename.h	244;"	d
Compute2WayHLoadImbalanceVec	Lib/rename.h	245;"	d
Compute2WayNodePartitionParams	Lib/rename.h	410;"	d
Compute2WayPartitionParams	Lib/rename.h	389;"	d
ComputeAdjWgtSums	Lib/metrics.c	/^void ComputeAdjWgtSums(GraphType* graph)$/;"	f
ComputeCoarseGraphSize	Lib/rename.h	113;"	d
ComputeConductance	Lib/metrics.c	/^float ComputeConductance(GraphType *graph, idxtype *where, int npart)$/;"	f
ComputeCut	Lib/metrics.c	/^int ComputeCut(GraphType *graph, idxtype *where)$/;"	f
ComputeCut	Lib/rename.h	102;"	d
ComputeElementBalance	Lib/rename.h	417;"	d
ComputeHKWayLoadImbalance	Lib/rename.h	287;"	d
ComputeKWayBalanceBoundary	Lib/rename.h	171;"	d
ComputeKWayBoundary	Lib/rename.h	170;"	d
ComputeKWayPartitionParams	Lib/rename.h	167;"	d
ComputeKWayVolGains	Lib/rename.h	191;"	d
ComputeKWayVolume	Lib/rename.h	180;"	d
ComputeLoadImbalance	Lib/rename.h	341;"	d
ComputeMaxNodeGain	Lib/rename.h	404;"	d
ComputeNCut	Lib/metrics.c	/^float ComputeNCut(GraphType *graph, idxtype *where, int npart)$/;"	f
ComputeNCutVector	Lib/metrics.c	/^float ComputeNCutVector(GraphType *graph, idxtype *where, int$/;"	f
ComputeNumEdgesCut	Lib/metrics.c	/^int ComputeNumEdgesCut(GraphType* graph, idxtype* where)$/;"	f
ComputePartitionBalance	Lib/rename.h	416;"	d
ComputePartitionInfo	Lib/rename.h	415;"	d
ComputeSubDomainGraph	Lib/rename.h	424;"	d
ComputeVolKWayBalanceBoundary	Lib/rename.h	194;"	d
ComputeVolKWayBoundary	Lib/rename.h	193;"	d
ComputeVolKWayPartitionParams	Lib/rename.h	190;"	d
ComputeVolSubDomainGraph	Lib/rename.h	183;"	d
ComputeVolSubset	Lib/metrics.c	/^idxtype ComputeVolSubset(GraphType* graph, idxtype* bisection)$/;"	f
ComputeVolume	Lib/rename.h	181;"	d
ConstructMinCoverSeparator	Lib/rename.h	396;"	d
ConstructMinCoverSeparator0	Lib/rename.h	395;"	d
ConstructSeparator	Lib/rename.h	394;"	d
ContractTmr	Lib/struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
CreateCoarseGraph	Lib/ccgraph.c	/^void CreateCoarseGraph(CtrlType *ctrl, GraphType *graph, int cnvtxs, idxtype *match, idxtype *perm)$/;"	f
CreateCoarseGraph	Lib/rename.h	85;"	d
CreateCoarseGraphNoMask	Lib/ccgraph.c	/^void CreateCoarseGraphNoMask(CtrlType *ctrl, GraphType *graph, int cnvtxs, idxtype *match, idxtype *perm)$/;"	f
CreateCoarseGraphNoMask	Lib/rename.h	86;"	d
CreateCoarseGraph_NVW	Lib/ccgraph.c	/^void CreateCoarseGraph_NVW(CtrlType *ctrl, GraphType *graph, int cnvtxs, idxtype *match, idxtype *perm)$/;"	f
CreateCoarseGraph_NVW	Lib/rename.h	87;"	d
CreateCoarseGraph_PowerLaw	Lib/ccgraph.c	/^void CreateCoarseGraph_PowerLaw(CtrlType *ctrl, GraphType *graph,$/;"	f
CreateGraph	Lib/memory.c	/^GraphType *CreateGraph(void)$/;"	f
CreateGraph	Lib/rename.h	226;"	d
CtrlType	Lib/struct.h	/^typedef struct controldef CtrlType;$/;"	t	typeref:struct:controldef
DBG_COARSEN	Lib/defs.h	236;"	d
DBG_IPART	Lib/defs.h	238;"	d
DBG_KWAYPINFO	Lib/defs.h	240;"	d
DBG_MOVEINFO	Lib/defs.h	239;"	d
DBG_OUTPUT	Lib/defs.h	235;"	d
DBG_REFINE	Lib/defs.h	237;"	d
DBG_SEPINFO	Lib/defs.h	241;"	d
DBG_TIME	Lib/defs.h	234;"	d
DirToUndirOptions	Lib/struct.h	/^typedef struct dirToUndirOptionsDef DirToUndirOptions;$/;"	t	typeref:struct:dirToUndirOptionsDef
EDegreeType	Lib/struct.h	/^typedef struct edegreedef EDegreeType;$/;"	t	typeref:struct:edegreedef
EliminateComponents	Lib/rename.h	427;"	d
EliminateSubDomainEdges	Lib/rename.h	425;"	d
EliminateVolSubDomainEdges	Lib/rename.h	184;"	d
EstimateCFraction	Lib/rename.h	112;"	d
FM_2WayEdgeRefine	Lib/rename.h	117;"	d
FM_2WayNodeBalance	Lib/rename.h	403;"	d
FM_2WayNodeRefine	Lib/rename.h	400;"	d
FM_2WayNodeRefineEqWgt	Lib/rename.h	401;"	d
FM_2WayNodeRefine_OneSided	Lib/rename.h	402;"	d
FindComponents	Lib/rename.h	139;"	d
FreeGraph	Lib/memory.c	/^void FreeGraph(GraphType *graph) $/;"	f
FreeGraph	Lib/rename.h	228;"	d
FreeWorkSpace	Lib/memory.c	/^void FreeWorkSpace(CtrlType *ctrl, GraphType *graph)$/;"	f
FreeWorkSpace	Lib/rename.h	221;"	d
GKfree	Lib/rename.h	439;"	d
GKfree	Lib/util.c	/^void GKfree(void **ptr1,...)$/;"	f
GKmalloc	Lib/macros.h	131;"	d
GKmalloc	Lib/rename.h	446;"	d
GKmalloc	Lib/util.c	/^void *GKmalloc(int nbytes, const char *msg)$/;"	f
GKmalloc	Lib/util.c	/^void *GKmalloc(long nbytes, const char *msg)$/;"	f
General2WayBalance	Lib/rename.h	77;"	d
GraphType	Lib/struct.h	/^typedef struct graphdef GraphType;$/;"	t	typeref:struct:graphdef
Greedy_KWayEdgeBalance	Lib/rename.h	161;"	d
Greedy_KWayEdgeBalanceMConn	Lib/rename.h	422;"	d
Greedy_KWayEdgeRefine	Lib/rename.h	160;"	d
Greedy_KWayVolBalance	Lib/rename.h	177;"	d
Greedy_KWayVolBalanceMConn	Lib/rename.h	178;"	d
GrowBisection	Lib/rename.h	145;"	d
GrowBisectionNode	Lib/rename.h	146;"	d
HASHFCT	Lib/macros.h	105;"	d
HEXDUALMETIS	Lib/rename.h	234;"	d
HEXNODALMETIS	Lib/rename.h	237;"	d
HORIZONTAL_IMBALANCE	Lib/defs.h	231;"	d
HTABLE_EMPTY	Lib/defs.h	213;"	d
HTLENGTH	Lib/defs.h	84;"	d
Hashtable	Lib/struct.h	/^typedef struct hashtabledef Hashtable;$/;"	t	typeref:struct:hashtabledef
IDF	Lib/defs.h	113;"	d
IDXTYPE_INT	Lib/struct.h	74;"	d
IFSET	Lib/macros.h	120;"	d
INCLUDES	Lib/Makefile	/^INCLUDES = -I. $/;"	m
INCLUDES	Programs/Makefile	/^INCLUDES = -I..\/Lib $/;"	m
INC_DEC	Lib/macros.h	98;"	d
INVD	Lib/defs.h	112;"	d
INVNORM	Lib/defs.h	114;"	d
INVSQRTD	Lib/defs.h	111;"	d
IPART_GGPKL	Lib/defs.h	188;"	d
IPART_GGPKLNODE	Lib/defs.h	189;"	d
IPART_McHPMETIS	Lib/defs.h	209;"	d
IPART_McPMETIS	Lib/defs.h	208;"	d
IPART_PMETIS	Lib/defs.h	196;"	d
IPART_RANDOM	Lib/defs.h	190;"	d
IType	Lib/struct.h	/^  int IType;			\/* The type of initial partitioning *\/$/;"	m	struct:controldef
Init2WayPartition	Lib/rename.h	143;"	d
InitGraph	Lib/memory.c	/^void InitGraph(GraphType *graph) $/;"	f
InitGraph	Lib/rename.h	227;"	d
InitPartTmr	Lib/struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
InitRandom	Lib/rename.h	471;"	d
InitRandom	Lib/util.c	/^void InitRandom(int seed)$/;"	f
InitSeparator	Lib/rename.h	144;"	d
InitTimers	Lib/rename.h	432;"	d
InitTimers	Lib/util.c	/^void InitTimers(CtrlType *ctrl)$/;"	f
IsBalanced	Lib/rename.h	169;"	d
IsBetter2wayBalance	Lib/rename.h	251;"	d
IsConnected	Lib/rename.h	137;"	d
IsConnected2	Lib/rename.h	138;"	d
IsConnectedSubdomain	Lib/rename.h	136;"	d
IsHBalanceBetterFT	Lib/rename.h	289;"	d
IsHBalanceBetterTT	Lib/rename.h	290;"	d
IsSeparable	Lib/rename.h	108;"	d
KMETIS_CTYPE	Lib/defs.h	124;"	d
KMETIS_DBGLVL	Lib/defs.h	127;"	d
KMETIS_ITYPE	Lib/defs.h	125;"	d
KMETIS_RTYPE	Lib/defs.h	126;"	d
KVMETIS_CTYPE	Lib/defs.h	157;"	d
KVMETIS_DBGLVL	Lib/defs.h	160;"	d
KVMETIS_ITYPE	Lib/defs.h	158;"	d
KVMETIS_RTYPE	Lib/defs.h	159;"	d
KWayVolUpdate	Lib/rename.h	179;"	d
KeyValueType	Lib/struct.h	/^struct KeyValueType {$/;"	s
KeyValueType	Lib/struct.h	/^typedef struct KeyValueType KeyValueType;$/;"	t	typeref:struct:KeyValueType
LARGENIPARTS	Lib/defs.h	218;"	d
LD	Lib/Makefile	/^LD = $(CC) -L. $/;"	m
LD	Programs/Makefile	/^LD = $(CC) $(LDOPTIONS) -L. -L..$/;"	m
LIBS	Programs/Makefile	/^LIBS = -lmlrmcl -lm$/;"	m
LTERM	Lib/defs.h	76;"	d
ListGraph	Lib/struct.h	/^typedef struct listgraphdef ListGraph;$/;"	t	typeref:struct:listgraphdef
ListInt	Lib/struct.h	/^typedef struct intlistdef ListInt;$/;"	t	typeref:struct:intlistdef
ListNodeType	Lib/struct.h	/^struct ListNodeType {$/;"	s
ListNodeType	Lib/struct.h	/^typedef struct ListNodeType ListNodeType;$/;"	t	typeref:struct:ListNodeType
ListWgt	Lib/struct.h	/^typedef struct wgtlistdef ListWgt;$/;"	t	typeref:struct:wgtlistdef
M	tools/evaluateClusters.py	/^	M = float(len(cluster))$/;"	v
MAKECSR	Lib/macros.h	150;"	d
MALLOC_CHECK	Lib/macros.h	135;"	d
MALLOC_CHECK	Lib/macros.h	142;"	d
MATCH_HASH	Lib/defs.h	183;"	d
MATCH_HEM	Lib/defs.h	174;"	d
MATCH_HEMN	Lib/defs.h	181;"	d
MATCH_POWERLAW_FC	Lib/defs.h	184;"	d
MATCH_RM	Lib/defs.h	173;"	d
MATCH_SBHEM_INFNORM	Lib/defs.h	180;"	d
MATCH_SBHEM_ONENORM	Lib/defs.h	179;"	d
MATCH_SHEBM_INFNORM	Lib/defs.h	178;"	d
MATCH_SHEBM_ONENORM	Lib/defs.h	177;"	d
MATCH_SHEM	Lib/defs.h	175;"	d
MATCH_SHEMKWAY	Lib/defs.h	176;"	d
MATCH_SHEMN	Lib/defs.h	182;"	d
MATCH_UNSPECIFIED	Lib/defs.h	185;"	d
MAXIDX	Lib/struct.h	94;"	d
MAXLINE	Lib/defs.h	74;"	d
MAXNCON	Lib/defs.h	78;"	d
MAXNOBJ	Lib/defs.h	79;"	d
MCCoarsen2Way	Lib/rename.h	216;"	d
MCGreedy_KWayEdgeBalanceHorizontal	Lib/rename.h	284;"	d
MCHMlevelEdgeBisection	Lib/rename.h	323;"	d
MCHMlevelRecursiveBisection	Lib/rename.h	321;"	d
MCMatch_HEM	Lib/rename.h	303;"	d
MCMatch_RM	Lib/rename.h	302;"	d
MCMatch_SBHEM	Lib/rename.h	306;"	d
MCMatch_SHEBM	Lib/rename.h	305;"	d
MCMatch_SHEM	Lib/rename.h	304;"	d
MCMlevelEdgeBisection	Lib/rename.h	322;"	d
MCMlevelKWayPartitioning	Lib/rename.h	279;"	d
MCMlevelRecursiveBisection	Lib/rename.h	320;"	d
MCRandom_KWayEdgeRefineHorizontal	Lib/rename.h	283;"	d
MERGEOBJ	Programs/Makefile	/^MERGEOBJ = mergeClusters.o$/;"	m
MLMCL_PRUNE_A	Lib/defs.h	100;"	d
MLMCL_PRUNE_B	Lib/defs.h	101;"	d
MLRMCLLIB	Programs/Makefile	/^MLRMCLLIB = ..\/libmlrmcl.a$/;"	m
MLRMCLOBJ	Programs/Makefile	/^MLRMCLOBJ = mlrmcl.o $/;"	m
MMDOrder	Lib/rename.h	358;"	d
MMDSWITCH	Lib/defs.h	229;"	d
MTHRESH	Lib/myqsort.c	77;"	d	file:
MatchTmr	Lib/struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
Match_HEM	Lib/match.c	/^void Match_HEM(CtrlType *ctrl, GraphType *graph)$/;"	f
Match_HEM	Lib/rename.h	200;"	d
Match_RM	Lib/match.c	/^void Match_RM(CtrlType *ctrl, GraphType *graph)$/;"	f
Match_RM	Lib/rename.h	198;"	d
Match_RM_NVW	Lib/match.c	/^void Match_RM_NVW(CtrlType *ctrl, GraphType *graph)$/;"	f
Match_RM_NVW	Lib/rename.h	199;"	d
Match_SHEM	Lib/match.c	/^void Match_SHEM(CtrlType *ctrl, GraphType *graph)$/;"	f
Match_SHEM	Lib/rename.h	201;"	d
Matrix	Lib/struct.h	/^typedef struct matrixdef Matrix;$/;"	t	typeref:struct:matrixdef
McKMETIS_CTYPE	Lib/defs.h	151;"	d
McKMETIS_DBGLVL	Lib/defs.h	154;"	d
McKMETIS_ITYPE	Lib/defs.h	152;"	d
McKMETIS_RTYPE	Lib/defs.h	153;"	d
McPMETIS_CTYPE	Lib/defs.h	145;"	d
McPMETIS_DBGLVL	Lib/defs.h	148;"	d
McPMETIS_ITYPE	Lib/defs.h	146;"	d
McPMETIS_RTYPE	Lib/defs.h	147;"	d
MinCover	Lib/rename.h	255;"	d
MinCover_Augment	Lib/rename.h	256;"	d
MinCover_ColDFS	Lib/rename.h	258;"	d
MinCover_Decompose	Lib/rename.h	257;"	d
MinCover_RowDFS	Lib/rename.h	259;"	d
MlevelEdgeBisection	Lib/rename.h	368;"	d
MlevelKWayPartitioning	Lib/rename.h	151;"	d
MlevelNestedDissection	Lib/rename.h	353;"	d
MlevelNestedDissectionCC	Lib/rename.h	354;"	d
MlevelNestedDissectionP	Lib/rename.h	363;"	d
MlevelNodeBisection	Lib/rename.h	356;"	d
MlevelNodeBisectionMultiple	Lib/rename.h	355;"	d
MlevelRecursiveBisection	Lib/rename.h	367;"	d
MlevelVolKWayPartitioning	Lib/rename.h	155;"	d
MocAllocate2WayPartitionMemory	Lib/rename.h	328;"	d
MocAllocateKWayPartitionMemory	Lib/rename.h	295;"	d
MocBalance2Way	Lib/rename.h	205;"	d
MocBalance2Way2	Lib/rename.h	210;"	d
MocCompute2WayPartitionParams	Lib/rename.h	329;"	d
MocComputeKWayBalanceBoundary	Lib/rename.h	298;"	d
MocComputeKWayPartitionParams	Lib/rename.h	296;"	d
MocFM_2WayEdgeRefine	Lib/rename.h	241;"	d
MocFM_2WayEdgeRefine2	Lib/rename.h	249;"	d
MocGeneral2WayBalance	Lib/rename.h	206;"	d
MocGeneral2WayBalance2	Lib/rename.h	211;"	d
MocGrowBisection	Lib/rename.h	264;"	d
MocGrowBisection2	Lib/rename.h	272;"	d
MocGrowBisectionNew2	Lib/rename.h	273;"	d
MocInit2WayBalance	Lib/rename.h	266;"	d
MocInit2WayBalance2	Lib/rename.h	274;"	d
MocInit2WayPartition	Lib/rename.h	263;"	d
MocInit2WayPartition2	Lib/rename.h	271;"	d
MocIsHBalanced	Lib/rename.h	288;"	d
MocProject2WayPartition	Lib/rename.h	330;"	d
MocProjectKWayPartition	Lib/rename.h	297;"	d
MocRandomBisection	Lib/rename.h	265;"	d
MocRefine2Way	Lib/rename.h	327;"	d
MocRefine2Way2	Lib/rename.h	334;"	d
MocRefineKWayHorizontal	Lib/rename.h	294;"	d
MoveGroup	Lib/rename.h	428;"	d
MoveGroupMConn	Lib/rename.h	426;"	d
N	tools/evaluateClusters.py	/^N = float(args[5])$/;"	v
N	tools/normMI.py	/^N = N_gt$/;"	v
NCUTOBJ	Programs/Makefile	/^NCUTOBJ = ncut.o $/;"	m
NEG_GAINSPAN	Lib/defs.h	82;"	d
NGR_PASSES	Lib/defs.h	215;"	d
NLGR_PASSES	Lib/defs.h	216;"	d
NORM_BC	Lib/defs.h	104;"	d
NORM_CC	Lib/defs.h	105;"	d
NRInfoType	Lib/struct.h	/^typedef struct nrinfodef NRInfoType;$/;"	t	typeref:struct:nrinfodef
N_cluster	tools/normMI.py	/^		N_cluster = N_cluster+1$/;"	v
N_cluster	tools/normMI.py	/^N_cluster = 0$/;"	v
N_gt	tools/normMI.py	/^N_gt = float(len(gtAssignments))$/;"	v
NbinCoeffs	tools/evaluateClusters.py	/^NbinCoeffs = {} $/;"	v
OBJS	Lib/Makefile	/^OBJS = coarsen.o match.o ccgraph.o memory.o \\$/;"	m
OEMETIS_CTYPE	Lib/defs.h	130;"	d
OEMETIS_DBGLVL	Lib/defs.h	133;"	d
OEMETIS_ITYPE	Lib/defs.h	131;"	d
OEMETIS_RTYPE	Lib/defs.h	132;"	d
OFLAG_CCMP	Lib/defs.h	97;"	d
OFLAG_COMPRESS	Lib/defs.h	96;"	d
ONMETIS_CTYPE	Lib/defs.h	136;"	d
ONMETIS_DBGLVL	Lib/defs.h	139;"	d
ONMETIS_ITYPE	Lib/defs.h	137;"	d
ONMETIS_NSEPS	Lib/defs.h	142;"	d
ONMETIS_OFLAGS	Lib/defs.h	140;"	d
ONMETIS_PFACTOR	Lib/defs.h	141;"	d
ONMETIS_RTYPE	Lib/defs.h	138;"	d
OPTION_CTYPE	Lib/defs.h	88;"	d
OPTION_DBGLVL	Lib/defs.h	91;"	d
OPTION_ITYPE	Lib/defs.h	89;"	d
OPTION_NSEPS	Lib/defs.h	94;"	d
OPTION_OFLAGS	Lib/defs.h	92;"	d
OPTION_PFACTOR	Lib/defs.h	93;"	d
OPTION_PTYPE	Lib/defs.h	87;"	d
OPTION_RTYPE	Lib/defs.h	90;"	d
OP_KMETIS	Lib/defs.h	165;"	d
OP_KVMETIS	Lib/defs.h	169;"	d
OP_OEMETIS	Lib/defs.h	166;"	d
OP_ONMETIS	Lib/defs.h	167;"	d
OP_ONWMETIS	Lib/defs.h	168;"	d
OP_PMETIS	Lib/defs.h	164;"	d
OR	Lib/macros.h	92;"	d
ORDER_UNBALANCE_FRACTION	Lib/defs.h	227;"	d
Options	Lib/struct.h	/^typedef struct optionsdef Options;$/;"	t	typeref:struct:optionsdef
PLUS_GAINSPAN	Lib/defs.h	81;"	d
PMETIS_CTYPE	Lib/defs.h	118;"	d
PMETIS_DBGLVL	Lib/defs.h	121;"	d
PMETIS_ITYPE	Lib/defs.h	119;"	d
PMETIS_RTYPE	Lib/defs.h	120;"	d
PMPLUSPMT	Lib/defs.h	108;"	d
PQueueDelete	Lib/rename.h	378;"	d
PQueueFree	Lib/rename.h	376;"	d
PQueueGetMax	Lib/rename.h	381;"	d
PQueueInit	Lib/rename.h	374;"	d
PQueueInsert	Lib/rename.h	377;"	d
PQueueReset	Lib/rename.h	375;"	d
PQueueSeeMax	Lib/rename.h	382;"	d
PQueueType	Lib/struct.h	/^struct PQueueType {$/;"	s
PQueueType	Lib/struct.h	/^typedef struct PQueueType PQueueType;$/;"	t	typeref:struct:PQueueType
PQueueUpdate	Lib/rename.h	379;"	d
PQueueUpdateUp	Lib/rename.h	380;"	d
PageRankOptions	Lib/struct.h	/^typedef struct pagerankOptionsDef PageRankOptions;$/;"	t	typeref:struct:pagerankOptionsDef
ParallelQSort	Lib/util.c	/^void ParallelQSort(idxtype *a, wgttype *b, int start, int end)$/;"	f
ParallelQSortFloatsInts	Lib/util.c	/^void ParallelQSortFloatsInts(wgttype *a, idxtype *b, int start,$/;"	f
ParallelQSortInts	Lib/util.c	/^void ParallelQSortInts(idxtype *a, idxtype *b, int start, int end)$/;"	f
ParallelQSortIntsUsingScores	Lib/util.c	/^void ParallelQSortIntsUsingScores(idxtype *a, idxtype *b, idxtype$/;"	f
ParallelQSortLongs	Lib/util.c	/^void ParallelQSortLongs(long *a, wgttype *b, int start, int end)$/;"	f
ParallelRandomPartition	Lib/util.c	/^int ParallelRandomPartition(idxtype* a, wgttype* b, int start,$/;"	f
ParallelRandomPartitionFloatsInts	Lib/util.c	/^int ParallelRandomPartitionFloatsInts(wgttype* a, idxtype* b, int start,$/;"	f
ParallelRandomPartitionInts	Lib/util.c	/^int ParallelRandomPartitionInts(idxtype* a, idxtype* b, int start,$/;"	f
ParallelRandomPartitionIntsUsingScores	Lib/util.c	/^int ParallelRandomPartitionIntsUsingScores(idxtype* a, idxtype*$/;"	f
ParallelRandomPartitionLongs	Lib/util.c	/^int ParallelRandomPartitionLongs(long* a, wgttype* b, int start,$/;"	f
PrintSubDomainGraph	Lib/rename.h	423;"	d
PrintTimers	Lib/rename.h	433;"	d
PrintTimers	Lib/util.c	/^void PrintTimers(CtrlType *ctrl)$/;"	f
Project2WayNodePartition	Lib/rename.h	411;"	d
Project2WayPartition	Lib/rename.h	390;"	d
ProjectKWayPartition	Lib/rename.h	168;"	d
ProjectTmr	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
ProjectVolKWayPartition	Lib/rename.h	192;"	d
PruneGraph	Lib/rename.h	98;"	d
QSortIntsUsingInts	Lib/util.c	/^void QSortIntsUsingInts(idxtype *a, idxtype *scores, int start,$/;"	f
RInfoType	Lib/struct.h	/^typedef struct rinfodef RInfoType;$/;"	t	typeref:struct:rinfodef
RTYPE_FM	Lib/defs.h	193;"	d
RTYPE_KWAYGREEDY	Lib/defs.h	200;"	d
RTYPE_KWAYRANDOM	Lib/defs.h	199;"	d
RTYPE_KWAYRANDOM_MCONN	Lib/defs.h	201;"	d
RTYPE_SEP1SIDED	Lib/defs.h	205;"	d
RTYPE_SEP2SIDED	Lib/defs.h	204;"	d
RType	Lib/struct.h	/^  int RType;			\/* The type of refinement *\/$/;"	m	struct:controldef
RandomBisection	Lib/rename.h	147;"	d
RandomInRange	Lib/macros.h	79;"	d
RandomInRange	Lib/macros.h	82;"	d
RandomInRangeFast	Lib/macros.h	80;"	d
RandomInRangeFast	Lib/macros.h	83;"	d
RandomPartition	Lib/util.c	/^int RandomPartition(wgttype* a, int start, int end)$/;"	f
RandomPartitionInts	Lib/util.c	/^int RandomPartitionInts(idxtype* a, int start, int end)$/;"	f
RandomPartitionIntsUsingInts	Lib/util.c	/^int RandomPartitionIntsUsingInts(idxtype* a, const idxtype *scores,$/;"	f
RandomPermute	Lib/rename.h	469;"	d
RandomPermute	Lib/util.c	/^void RandomPermute(int n, idxtype *p, int flag)$/;"	f
RandomPermuteWgttype	Lib/util.c	/^void RandomPermuteWgttype(int n, wgttype *p, int flag)$/;"	f
RandomSelect	Lib/util.c	/^wgttype RandomSelect(wgttype *a, int start, int end, int i)$/;"	f
RandomSelectInts	Lib/util.c	/^idxtype RandomSelectInts(idxtype *a, int start, int end, int i)$/;"	f
Random_KWayEdgeRefine	Lib/rename.h	159;"	d
Random_KWayEdgeRefineMConn	Lib/rename.h	421;"	d
Random_KWayVolRefine	Lib/rename.h	175;"	d
Random_KWayVolRefineMConn	Lib/rename.h	176;"	d
RandomizeGraph	Lib/rename.h	135;"	d
ReAdjustMemory	Lib/ccgraph.c	/^void ReAdjustMemory(GraphType *graph, GraphType *cgraph, int dovsize) $/;"	f
ReAdjustMemory	Lib/rename.h	89;"	d
ReadGraph	Lib/io.c	/^void ReadGraph(GraphType *graph, const char *filename, int *wgtflag,$/;"	f
ReadMatrix	Lib/io.c	/^void ReadMatrix(Matrix *m, char *filename, wgttype threshold)$/;"	f
ReadMesh	Lib/io.c	/^idxtype *ReadMesh(const char *filename, int *ne, int *nn, int *etype)$/;"	f
RefTmr	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
Refine2Way	Lib/rename.h	387;"	d
Refine2WayNode	Lib/rename.h	408;"	d
RefineKWay	Lib/rename.h	165;"	d
RefineVolKWay	Lib/rename.h	188;"	d
SMALLNIPARTS	Lib/defs.h	219;"	d
SWAP	Lib/macros.h	95;"	d
SelectQueue	Lib/rename.h	242;"	d
SelectQueue2	Lib/rename.h	250;"	d
SelectQueue3	Lib/rename.h	212;"	d
SelectQueueOneWay2	Lib/rename.h	275;"	d
SelectQueueoneWay	Lib/rename.h	267;"	d
SepTmr	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
SetUpCoarseGraph	Lib/ccgraph.c	/^GraphType *SetUpCoarseGraph(GraphType *graph, int cnvtxs, int dovsize)$/;"	f
SetUpCoarseGraph	Lib/rename.h	88;"	d
SetUpGraph	Lib/rename.h	131;"	d
SetUpGraph2	Lib/rename.h	133;"	d
SetUpGraphKway	Lib/rename.h	132;"	d
SetUpSplitGraph	Lib/rename.h	370;"	d
SplitGraphOrder	Lib/rename.h	357;"	d
SplitGraphOrderCC	Lib/rename.h	359;"	d
SplitGraphPart	Lib/rename.h	369;"	d
SplitTmr	Lib/struct.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
TETDUALMETIS	Lib/rename.h	233;"	d
TETNODALMETIS	Lib/rename.h	236;"	d
THRESH	Lib/myqsort.c	76;"	d	file:
TRIDUALMETIS	Lib/rename.h	232;"	d
TRINODALMETIS	Lib/rename.h	235;"	d
TotalTmr	Lib/struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
UInt32	Lib/struct.h	/^typedef unsigned int UInt32;$/;"	t
UNBALANCE_FRACTION	Lib/defs.h	223;"	d
UNMATCHED	Lib/defs.h	211;"	d
UncoarsenTmr	Lib/struct.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
VEDegreeType	Lib/struct.h	/^typedef struct vedegreedef VEDegreeType;$/;"	t	typeref:struct:vedegreedef
VPInfoType	Lib/struct.h	/^typedef struct vpwgtdef VPInfoType;$/;"	t	typeref:struct:vpwgtdef
VRInfoType	Lib/struct.h	/^typedef struct vrinfodef VRInfoType;$/;"	t	typeref:struct:vrinfodef
VolSetUpGraph	Lib/rename.h	134;"	d
WGTTYPE_FLOAT	Lib/struct.h	86;"	d
WorkSpaceType	Lib/struct.h	/^typedef struct workspacedef WorkSpaceType;$/;"	t	typeref:struct:workspacedef
WriteGraph	Lib/io.c	/^void WriteGraph(const char *filename, int nvtxs, idxtype *xadj, idxtype *adjncy)$/;"	f
WriteGraphWithWts	Lib/io.c	/^void WriteGraphWithWts(const char *filename, int nvtxs, idxtype *xadj,$/;"	f
WriteMappedTxtGraphWithWts	Lib/io.c	/^void WriteMappedTxtGraphWithWts(const char *filename, int fullNvtxs, $/;"	f
WriteMatrix	Lib/io.c	/^void WriteMatrix(const char *filename, int nvtxs, idxtype *xadj,$/;"	f
WriteMeshPartition	Lib/io.c	/^void WriteMeshPartition(const char *fname, int nparts, int ne, idxtype *epart, int nn, idxtype *npart)$/;"	f
WriteMocGraph	Lib/io.c	/^void WriteMocGraph(GraphType *graph)$/;"	f
WritePartition	Lib/io.c	/^void WritePartition(const char *fname, idxtype *part, int n, int nparts)$/;"	f
WritePermutation	Lib/io.c	/^void WritePermutation(const char *fname, idxtype *iperm, int n)$/;"	f
WriteRMap	Lib/io.c	/^void WriteRMap(const char *fname, idxtype *map, int n)$/;"	f
WriteTxtGraph	Lib/io.c	/^void WriteTxtGraph(const char *filename, int nvtxs, idxtype *xadj, idxtype *adjncy)$/;"	f
WspaceAvail	Lib/memory.c	/^int WspaceAvail(CtrlType *ctrl)$/;"	f
WspaceAvail	Lib/rename.h	222;"	d
XOR	Lib/macros.h	93;"	d
actualNumOutClusters	tools/evaluateClusters.py	/^		actualNumOutClusters = actualNumOutClusters + 1$/;"	v
actualNumOutClusters	tools/evaluateClusters.py	/^actualNumOutClusters = 0$/;"	v
add	Lib/mclbase.c	/^Matrix* add(Matrix* M0, Matrix* M1)$/;"	f
addInLinks	tools/sortedEdgesToMetis.py	/^	addInLinks = False$/;"	v
addInLinks	tools/sortedEdgesToMetis.py	/^	addInLinks = True$/;"	v
addInLinks	tools/sortedEdgesToMetis.py	/^addInLinks = 0$/;"	v
addSelfLoops	Lib/mclutils.c	/^Matrix* addSelfLoops(Matrix* M)$/;"	f
addToList	Lib/merge.c	/^void addToList(ListInt *l, int a)$/;"	f
addToList	Lib/merge.c	/^void addToList(ListWgt *l, int a)$/;"	f
adjListMap	tools/sortedEdgesToMetis.py	/^adjListMap = {}$/;"	v
adjLists	Lib/struct.h	/^	ListInt* adjLists;$/;"	m	struct:listgraphdef
adjncy	Lib/struct.h	/^	idxtype *xadj, *adjncy, *adjwgt;$/;"	m	struct:threadData
adjncy	Lib/struct.h	/^	idxtype* adjncy;$/;"	m	struct:matrixdef
adjncy	Lib/struct.h	/^  idxtype *adjncy;		\/* Array that stores the adjacency lists of nvtxs *\/$/;"	m	struct:graphdef
adjwgt	Lib/struct.h	/^	idxtype *xadj, *adjncy, *adjwgt;$/;"	m	struct:threadData
adjwgt	Lib/struct.h	/^	wgttype* adjwgt; \/* array that stores weights of the$/;"	m	struct:matrixdef
adjwgt	Lib/struct.h	/^  idxtype *adjwgt;		\/* Array that stores the weights of the adjacency lists *\/$/;"	m	struct:graphdef
adjwgtsum	Lib/struct.h	/^	wgttype* adjwgtsum; \/* sum of adjacency weights of each node,$/;"	m	struct:matrixdef
adjwgtsum	Lib/struct.h	/^  idxtype *adjwgtsum;		\/* The sum of the adjacency weight of each vertex *\/$/;"	m	struct:graphdef
allInOneStep	Lib/mclbase.c	/^Matrix* allInOneStep(Matrix* flows, Matrix* input_adj, idxtype*$/;"	f
allocListGraph	Lib/merge.c	/^ListGraph* allocListGraph(int nvtxs, int wgtflag, int$/;"	f
allocListInt	Lib/merge.c	/^void allocListInt(ListInt *l, int initSize, int increment)$/;"	f
allocListWgt	Lib/merge.c	/^void allocListWgt(ListWgt *l, int initSize, int increment)$/;"	f
allocMatrix	Lib/mclutils.c	/^Matrix* allocMatrix(int nvtxs, int nedges, int allocSum, int$/;"	f
allocSize	Lib/struct.h	/^	int allocSize;$/;"	m	struct:intlistdef
allocSize	Lib/struct.h	/^	int allocSize;$/;"	m	struct:wgtlistdef
alpha	Lib/struct.h	/^	wgttype alpha; \/\/ random jump probability.$/;"	m	struct:pagerankOptionsDef
amax	Lib/macros.h	88;"	d
amin	Lib/macros.h	89;"	d
args	tools/convertToClusterLists.py	/^	args = sys.argv$/;"	v
args	tools/evaluateClusters.py	/^args = sys.argv$/;"	v
args	tools/normMI.py	/^args = sys.argv$/;"	v
args	tools/sortedEdgesToMetis.py	/^args=sys.argv$/;"	v
assignClustersToHubs	Lib/util.c	/^void assignClustersToHubs(idxtype* indices, idxtype* map, int n,$/;"	f
attractors	Lib/struct.h	/^	idxtype* attractors; \/* the row with the maximum weight in a$/;"	m	struct:matrixdef
auxcore	Lib/struct.h	/^  idxtype *auxcore;			\/* This points to the memory of the edegrees *\/$/;"	m	struct:workspacedef
bcWeight	Lib/struct.h	/^	wgttype bcWeight;$/;"	m	struct:dirToUndirOptionsDef
bestPvalue	tools/evaluateClusters.py	/^bestPvalue = 0$/;"	v
bestf	tools/evaluateClusters.py	/^					bestf = fmeasure$/;"	v
bestf	tools/evaluateClusters.py	/^				bestf = fmeasure$/;"	v
bestf	tools/evaluateClusters.py	/^	bestf = float(0)$/;"	v
bestf_gtClusterId	tools/evaluateClusters.py	/^					bestf_gtClusterId = gtCluster$/;"	v
bestf_gtClusterId	tools/evaluateClusters.py	/^	bestf_gtClusterId = -1$/;"	v
bestp	tools/evaluateClusters.py	/^					bestp = prec$/;"	v
bestp	tools/evaluateClusters.py	/^				bestp = prec$/;"	v
bestp	tools/evaluateClusters.py	/^	bestp = float(0)$/;"	v
bestpvalue	tools/evaluateClusters.py	/^				bestpvalue = pvalue$/;"	v
bestpvalue	tools/evaluateClusters.py	/^	bestpvalue = float(0)$/;"	v
bestpvalue_gtClusterId	tools/evaluateClusters.py	/^				bestpvalue_gtClusterId = gtCluster$/;"	v
bestpvalue_gtClusterId	tools/evaluateClusters.py	/^	bestpvalue_gtClusterId = -1$/;"	v
bestr	tools/evaluateClusters.py	/^					bestr = rec$/;"	v
bestr	tools/evaluateClusters.py	/^				bestr = rec$/;"	v
bestr	tools/evaluateClusters.py	/^	bestr = float(0)$/;"	v
blockSize	Lib/struct.h	/^	int blockSize;$/;"	m	struct:dirToUndirOptionsDef
bndind	Lib/struct.h	/^  idxtype *bndptr, *bndind;$/;"	m	struct:graphdef
bndptr	Lib/struct.h	/^  idxtype *bndptr, *bndind;$/;"	m	struct:graphdef
bsearch_insertPos	Lib/util.c	/^int bsearch_insertPos(idxtype *a, idxtype key, int start, int end)$/;"	f
buckets	Lib/struct.h	/^  ListNodeType **buckets;$/;"	m	struct:PQueueType
cCount	tools/normMI.py	/^	cCount = float(cCount)$/;"	v
calculateMaxAndSum	Lib/mclbase.c	/^void calculateMaxAndSum(Matrix* a)$/;"	f
cass	tools/normMI.py	/^		cass = int(t[0])$/;"	v
cass	tools/normMI.py	/^		cass = int(t[1])$/;"	v
ccore	Lib/struct.h	/^  int maxcore, ccore;$/;"	m	struct:workspacedef
cdegree	Lib/struct.h	/^  int cdegree;$/;"	m	struct:workspacedef
changeAdjMatrix	Lib/rmcl.c	/^Matrix* changeAdjMatrix(Matrix* flows, Matrix* adj, idxtype*$/;"	f
changeBetweenMatrices	Lib/mclbase.c	/^void changeBetweenMatrices(Matrix* M0, Matrix* M1, wgttype* c)$/;"	f
charsum	Lib/rename.h	461;"	d
charsum	Lib/util.c	/^int charsum(int n, const char *x)$/;"	f
checksums	Lib/mclbase.c	/^void checksums(Matrix* M)$/;"	f
cleartimer	Lib/macros.h	111;"	d
cluster	tools/evaluateClusters.py	/^	cluster = outClusters[clusterId]$/;"	v
clusterCount	tools/normMI.py	/^		clusterCount = float(clusterCounts[cluster])$/;"	v
clusterCounts	tools/normMI.py	/^clusterCounts = []$/;"	v
clusterId	tools/evaluateClusters.py	/^	clusterId = int(tokens[1])$/;"	v
clusterMap	tools/normMI.py	/^clusterMap = {}$/;"	v
clusters	tools/convertToClusterLists.py	/^	clusters = convertmetisoutput(args[1])$/;"	v
cmap	Lib/struct.h	/^  idxtype *cmap;$/;"	m	struct:graphdef
cmapass	tools/normMI.py	/^		cmapass = clusterMap[cass]$/;"	v
coarsenTo	Lib/struct.h	/^	int coarsenTo;$/;"	m	struct:optionsdef
coarser	Lib/struct.h	/^  struct graphdef *coarser, *finer;$/;"	m	struct:graphdef	typeref:struct:graphdef::graphdef
col_id	tools/sortedEdgesToMetis.py	/^	col_id = int(float(tokens[1]))$/;"	v
compSizeDistribution	Lib/io.c	/^idxtype* compSizeDistribution(GraphType* graph, int$/;"	f
compareints	Lib/mclbase.c	/^int compareints(const void * a, const void * b)$/;"	f
comparewgttypes	Lib/mclbase.c	/^int comparewgttypes(const void * a, const void * b)$/;"	f
computeCutAndVol	Lib/metrics.c	/^void computeCutAndVol(GraphType* graph, idxtype* members, int$/;"	f
computeThreshold	Lib/mclbase.c	/^wgttype computeThreshold(wgttype avg, wgttype max)$/;"	f
controldef	Lib/struct.h	/^struct controldef {$/;"	s
convergeThreshold	Lib/struct.h	/^	wgttype convergeThreshold;$/;"	m	struct:pagerankOptionsDef
conversionMethod	Lib/struct.h	/^	int conversionMethod;$/;"	m	struct:dirToUndirOptionsDef
convertMetisOutputToClusterLists	Lib/merge.c	/^idxtype* convertMetisOutputToClusterLists(const idxtype* part, int$/;"	f
converttoclusterlists	tools/convertToClusterLists.py	/^def converttoclusterlists(fname):$/;"	f
copyListInt	Lib/merge.c	/^void copyListInt(ListInt *dest, ListInt *src)$/;"	f
copyListWgt	Lib/merge.c	/^void copyListWgt(ListWgt *dest, ListWgt *src)$/;"	f
core	Lib/struct.h	/^  idxtype *core;			\/* Where pairs, indices, and degrees are coming from *\/$/;"	m	struct:workspacedef
createClusterGraph	Lib/merge.c	/^ListGraph* createClusterGraph(const idxtype *part, int nparts,$/;"	f
currentSize	Lib/struct.h	/^	int currentSize;$/;"	m	struct:matrixdef
current_row_id	tools/sortedEdgesToMetis.py	/^		current_row_id = current_row_id + 1$/;"	v
current_row_id	tools/sortedEdgesToMetis.py	/^current_row_id = 0$/;"	v
dbglvl	Lib/struct.h	/^  int dbglvl;			\/* Controls the debuging output of the program *\/$/;"	m	struct:controldef
delimiter	tools/sortedEdgesToMetis.py	/^delimiter = " "$/;"	v
dfTraversal	Lib/util.c	/^void dfTraversal(GraphType *graph, idxtype root, idxtype* visited, int* nVisited)$/;"	f
dfTraversalMatrix	Lib/util.c	/^void dfTraversalMatrix(Matrix *graph, idxtype root, idxtype*$/;"	f
diffTwoColumns	Lib/mclbase.c	/^wgttype diffTwoColumns(Matrix *flows, int col1, int col2)$/;"	f
dirToUndirOptionsDef	Lib/struct.h	/^struct dirToUndirOptionsDef{$/;"	s
dpr_threshold	Lib/struct.h	/^	float dpr_threshold;$/;"	m	struct:optionsdef
dprmcl	Lib/rmcl.c	/^Matrix* dprmcl(Matrix* flows, Matrix* adj, GraphType* graph, $/;"	f
dprmclWrapper	Lib/rmcl.c	/^void dprmclWrapper(int* nvtxs, idxtype* xadj, idxtype* adjncy, idxtype$/;"	f
dumpMatrix	Lib/mclutils.c	/^void dumpMatrix(Matrix* a)$/;"	f
dump_graph	Lib/mclutils.c	/^void dump_graph(GraphType *graph)$/;"	f
ed	Lib/struct.h	/^  idxtype *id, *ed;$/;"	m	struct:graphdef
ed	Lib/struct.h	/^  idxtype ed, ned;$/;"	m	struct:vedegreedef
ed	Lib/struct.h	/^  idxtype ed;$/;"	m	struct:edegreedef
ed	Lib/struct.h	/^ int id, ed, nid;            	\/* ID\/ED of nodes *\/$/;"	m	struct:vrinfodef
ed	Lib/struct.h	/^ int id, ed;            	\/* ID\/ED of nodes *\/$/;"	m	struct:rinfodef
edegreedef	Lib/struct.h	/^struct edegreedef {$/;"	s
edegrees	Lib/struct.h	/^  EDegreeType *edegrees;$/;"	m	struct:workspacedef
edegrees	Lib/struct.h	/^ EDegreeType *edegrees;     	\/* List of edges *\/$/;"	m	struct:rinfodef
edegrees	Lib/struct.h	/^ VEDegreeType *edegrees;     	\/* List of edges *\/$/;"	m	struct:vrinfodef
edegrees	Lib/struct.h	/^ idxtype edegrees[2];  $/;"	m	struct:nrinfodef
errexit	Lib/rename.h	438;"	d
errexit	Lib/util.c	/^void errexit(char *f_str,...)$/;"	f
exact	Lib/struct.h	/^	int exact;$/;"	m	struct:optionsdef
exactPrune	Lib/mclbase.c	/^wgttype exactPrune(int *n, idxtype* adjncy, wgttype* adjwgt,$/;"	f
exactPruneGraph	Lib/mclbase.c	/^void exactPruneGraph(GraphType* graph, int l, idxtype thresh )$/;"	f
exactPruneMatrix	Lib/mclbase.c	/^void exactPruneMatrix(Matrix* M, int l)$/;"	f
expand	Lib/mclbase.c	/^Matrix* expand(Matrix* M, Matrix* M0)$/;"	f
expand_ht	Lib/mclbase.c	/^Matrix* expand_ht(Matrix* M, Matrix* M0, idxtype*$/;"	f
factArray	tools/evaluateClusters.py	/^factArray = [0, 0]$/;"	v
finer	Lib/struct.h	/^  struct graphdef *coarser, *finer;$/;"	m	struct:graphdef	typeref:struct:graphdef::
fmalloc	Lib/macros.h	127;"	d
fmalloc	Lib/rename.h	443;"	d
fmalloc	Lib/util.c	/^float *fmalloc(int n, const char *msg)$/;"	f
fmeasure	tools/evaluateClusters.py	/^		fmeasure = 2*prec*rec\/(prec+rec)$/;"	v
freeMatrix	Lib/mclutils.c	/^void freeMatrix(Matrix* a)$/;"	f
fwspacefree	Lib/memory.c	/^void fwspacefree(CtrlType *ctrl, int n)$/;"	f
fwspacemalloc	Lib/memory.c	/^float *fwspacemalloc(CtrlType *ctrl, int n)$/;"	f
fwspacemalloc	Lib/rename.h	225;"	d
gamma	Lib/struct.h	/^	float gamma;$/;"	m	struct:optionsdef
gdata	Lib/struct.h	/^  idxtype *gdata, *rdata;	\/* Memory pools for graph and refinement data.$/;"	m	struct:graphdef
genmmd	Lib/rename.h	312;"	d
getAttractorsForAll	Lib/mclutils.c	/^void getAttractorsForAll(Matrix* M)$/;"	f
getCutGraph	Lib/subgraphs.c	/^GraphType* getCutGraph(GraphType* graph, idxtype* indices, $/;"	f
getDegreeHistogram	Lib/metrics.c	/^idxtype* getDegreeHistogram(GraphType* graph, int* maxDegree, int$/;"	f
getDprAdjMatrix	Lib/mclbase.c	/^Matrix* getDprAdjMatrix(Matrix* flows, Matrix* adj, idxtype*$/;"	f
getLogBin	Lib/metrics.c	/^int getLogBin(int a)$/;"	f
getNodesToComponentMap	Lib/io.c	/^idxtype* getNodesToComponentMap(Matrix* graph1, int *numComponents,$/;"	f
getPermutedGraph	Lib/mclutils.c	/^void getPermutedGraph(idxtype* perm, idxtype* revPerm, int nvtxs, $/;"	f
getRowSums	Lib/mclbase.c	/^wgttype* getRowSums(Matrix* a)$/;"	f
getSubgraph	Lib/subgraphs.c	/^void getSubgraph(GraphType *graph, idxtype* newIds, int new_nvtxs, int$/;"	f
getTranspose	Lib/mclbase.c	/^Matrix* getTranspose(Matrix* M)$/;"	f
getTranspose2	Lib/mclbase.c	/^Matrix* getTranspose2(Matrix* M)$/;"	f
getWeightsHistogram	Lib/metrics.c	/^idxtype* getWeightsHistogram(GraphType* graph, int* maxWeight, int$/;"	f
gettimer	Lib/macros.h	114;"	d
globallySampleEdges	Lib/subgraphs.c	/^void globallySampleEdges(int nvtxs, int nedges, idxtype* xadj, idxtype*$/;"	f
graphdef	Lib/struct.h	/^struct graphdef {$/;"	s
gtAssignments	tools/normMI.py	/^gtAssignments = {}$/;"	v
gtClusterCounts	tools/normMI.py	/^gtClusterCounts = {}$/;"	v
gtClusterSizes	tools/evaluateClusters.py	/^gtClusterSizes = {}$/;"	v
gtCount	tools/normMI.py	/^	gtCount = float(gtCount)$/;"	v
gtCounts	tools/normMI.py	/^gtCounts = []$/;"	v
gtMap	tools/normMI.py	/^gtMap = {}$/;"	v
gtMemberships	tools/evaluateClusters.py	/^gtMemberships = []$/;"	v
gtass	tools/normMI.py	/^		gtass = gtAssignments[id]$/;"	v
gtc	tools/normMI.py	/^		gtc = int(t[0])$/;"	v
gtc	tools/normMI.py	/^		gtc = int(t[1])$/;"	v
gtcCount	tools/normMI.py	/^	gtcCount = math.log(float(gtCounts[gtc]),2)$/;"	v
gtcc	tools/normMI.py	/^	gtcc = gtClusterCounts[gtc]$/;"	v
gtccCount	tools/normMI.py	/^		gtccCount = float(gtcc[cluster])$/;"	v
gv	Lib/struct.h	/^  idxtype gv;$/;"	m	struct:vedegreedef
gv	Lib/struct.h	/^ int gv;            		\/* IV\/EV of nodes *\/$/;"	m	struct:vrinfodef
h_cluster	tools/normMI.py	/^	h_cluster = h_cluster+(cCount\/N_cluster)*(logN_cluster-math.log(cCount,2))$/;"	v
h_cluster	tools/normMI.py	/^h_cluster = 0 #entropy of cluster assignments$/;"	v
h_gtc	tools/normMI.py	/^	h_gtc = h_gtc+(gtCount\/N)*(logN-math.log(gtCount,2))$/;"	v
h_gtc	tools/normMI.py	/^h_gtc = 0 # entropy of ground truth assignments$/;"	v
hashes	Lib/struct.h	/^	idxtype *hashes;$/;"	m	struct:hashtabledef
hashtabledef	Lib/struct.h	/^struct hashtabledef$/;"	s
heap	Lib/struct.h	/^  KeyValueType *heap;$/;"	m	struct:PQueueType
histogram	Lib/metrics.c	/^idxtype* histogram(idxtype* values, int n, int numUnique)$/;"	f
hubPct	Lib/struct.h	/^	float hubPct;$/;"	m	struct:optionsdef
hubRemoval	Lib/struct.h	/^	int hubRemoval;$/;"	m	struct:optionsdef
iamax	Lib/rename.h	451;"	d
iamax	Lib/util.c	/^int iamax(int n, int *x)$/;"	f
id	Lib/struct.h	/^  idxtype *id, *ed;$/;"	m	struct:graphdef
id	Lib/struct.h	/^  int id;                       	\/* The id value of the node *\/$/;"	m	struct:ListNodeType
id	Lib/struct.h	/^ int id, ed, nid;            	\/* ID\/ED of nodes *\/$/;"	m	struct:vrinfodef
id	Lib/struct.h	/^ int id, ed;            	\/* ID\/ED of nodes *\/$/;"	m	struct:rinfodef
id	tools/normMI.py	/^		id = int(t[0])$/;"	v
id	tools/normMI.py	/^		id = lineNo$/;"	v
idxadd	Lib/rename.h	460;"	d
idxadd	Lib/util.c	/^void idxadd(int n, idxtype *x, idxtype *y)$/;"	f
idxamax	Lib/rename.h	452;"	d
idxamax	Lib/util.c	/^int idxamax(int n, idxtype *x)$/;"	f
idxamax_strd	Lib/rename.h	453;"	d
idxamax_strd	Lib/util.c	/^int idxamax_strd(int n, idxtype *x, int incx)$/;"	f
idxamin	Lib/rename.h	456;"	d
idxamin	Lib/util.c	/^int idxamin(int n, idxtype *x)$/;"	f
idxcopy	Lib/macros.h	103;"	d
idxmalloc	Lib/macros.h	128;"	d
idxmalloc	Lib/rename.h	442;"	d
idxmalloc	Lib/util.c	/^idxtype *idxmalloc(int n, const char *msg)$/;"	f
idxset	Lib/rename.h	449;"	d
idxset	Lib/util.c	/^idxtype *idxset(int n, idxtype val, idxtype *x)$/;"	f
idxsmalloc	Lib/macros.h	130;"	d
idxsmalloc	Lib/rename.h	445;"	d
idxsmalloc	Lib/util.c	/^idxtype *idxsmalloc(int n, idxtype ival, const char *msg)$/;"	f
idxsum	Lib/rename.h	458;"	d
idxsum	Lib/util.c	/^int idxsum(int n, idxtype *x)$/;"	f
idxsum_strd	Lib/rename.h	459;"	d
idxsum_strd	Lib/util.c	/^int idxsum_strd(int n, idxtype *x, int incx)$/;"	f
idxtype	Lib/struct.h	/^typedef int idxtype;$/;"	t
idxtype	Lib/struct.h	/^typedef short idxtype;$/;"	t
idxwspacefree	Lib/memory.c	/^void idxwspacefree(CtrlType *ctrl, int n)$/;"	f
idxwspacefree	Lib/rename.h	224;"	d
idxwspacemalloc	Lib/memory.c	/^idxtype *idxwspacemalloc(CtrlType *ctrl, int n)$/;"	f
idxwspacemalloc	Lib/rename.h	223;"	d
iidxsort	Lib/myqsort.c	/^void iidxsort(int n, idxtype *base)$/;"	f
iidxsort	Lib/rename.h	346;"	d
iintsort	Lib/myqsort.c	/^void iintsort(int n, int *base)$/;"	f
iintsort	Lib/rename.h	347;"	d
iiqst	Lib/myqsort.c	/^static void iiqst(int *base, int *max)$/;"	f	file:
ikeysort	Lib/myqsort.c	/^void ikeysort(int n, KeyValueType *base)$/;"	f
ikeysort	Lib/rename.h	348;"	d
ikeyvalsort	Lib/myqsort.c	/^void ikeyvalsort(int n, KeyValueType *base)$/;"	f
ikeyvalsort	Lib/rename.h	349;"	d
imalloc	Lib/macros.h	126;"	d
imalloc	Lib/rename.h	441;"	d
imalloc	Lib/util.c	/^int *imalloc(int n, const char *msg)$/;"	f
imax	Lib/struct.h	/^  int imax[2][MAXNCON];$/;"	m	struct:vpwgtdef
increment	Lib/struct.h	/^	int increment;$/;"	m	struct:intlistdef
increment	Lib/struct.h	/^	int increment;$/;"	m	struct:wgtlistdef
inflate	Lib/mclbase.c	/^void inflate(Matrix* a, float gamma)$/;"	f
initOptions	Lib/util.c	/^void initOptions(Options* opt)$/;"	f
inputFile	tools/sortedEdgesToMetis.py	/^inputFile = file(args[1],"r")$/;"	v
inputNormalizer	tools/evaluateClusters.py	/^	inputNormalizer = float(args[8])$/;"	v
inputNormalizer	tools/evaluateClusters.py	/^inputNormalizer = 0$/;"	v
insertLastElement	Lib/mclbase.c	/^int insertLastElement(idxtype* adjncy, wgttype* adjwgt, int count)$/;"	f
intersect2	tools/evaluateClusters.py	/^		intersect2 = True$/;"	v
intersect2	tools/evaluateClusters.py	/^intersect2 = False$/;"	v
intersects	tools/evaluateClusters.py	/^	intersects = {}$/;"	v
intlistdef	Lib/struct.h	/^struct intlistdef{$/;"	s
invDegreeType	Lib/struct.h	/^	int invDegreeType;$/;"	m	struct:dirToUndirOptionsDef
isConverged	Lib/mclutils.c	/^int isConverged(idxtype* oldAttr, idxtype* newAttr, int n)$/;"	f
isConverged2	Lib/mclutils.c	/^int isConverged2(idxtype* oldAttr, idxtype* newAttr, int n)$/;"	f
isDirected	Lib/struct.h	/^  int isDirected; $/;"	m	struct:graphdef
isFvalues	tools/evaluateClusters.py	/^		isFvalues = True$/;"	v
isFvalues	tools/evaluateClusters.py	/^isFvalues = False $/;"	v
isGraphConnected	Lib/io.c	/^int isGraphConnected(GraphType *graph)$/;"	f
isOrgGraph	Lib/struct.h	/^  int isOrgGraph; $/;"	m	struct:graphdef
iset	Lib/rename.h	448;"	d
iset	Lib/util.c	/^int *iset(int n, int val, int *x)$/;"	f
ismalloc	Lib/macros.h	129;"	d
ismalloc	Lib/rename.h	444;"	d
ismalloc	Lib/util.c	/^int *ismalloc(int n, int ival, const char *msg)$/;"	f
ispow2	Lib/rename.h	470;"	d
ispow2	Lib/util.c	/^int ispow2(int a)$/;"	f
isum	Lib/rename.h	462;"	d
isum	Lib/util.c	/^int isum(int n, int *x)$/;"	f
iter_per_level	Lib/struct.h	/^	int iter_per_level;$/;"	m	struct:optionsdef
k	Lib/struct.h	/^	int k;$/;"	m	struct:optionsdef
key	Lib/struct.h	/^  idxtype key;$/;"	m	struct:KeyValueType
keyiqst	Lib/myqsort.c	/^static void keyiqst(KeyValueType *base, KeyValueType *max)$/;"	f	file:
keyvaliqst	Lib/myqsort.c	/^static void keyvaliqst(KeyValueType *base, KeyValueType *max)$/;"	f	file:
l	Lib/struct.h	/^	idxtype* l;$/;"	m	struct:intlistdef
l	Lib/struct.h	/^	wgttype* l;$/;"	m	struct:wgtlistdef
l	tools/evaluateClusters.py	/^	l = float(len(outClusters))$/;"	v
l	tools/sortedEdgesToMetis.py	/^			l = adjListMap[current_row_id]$/;"	v
label	Lib/struct.h	/^  idxtype *label;$/;"	m	struct:graphdef
length	Lib/struct.h	/^	int length;$/;"	m	struct:intlistdef
length	Lib/struct.h	/^	int length;$/;"	m	struct:wgtlistdef
line	tools/evaluateClusters.py	/^	line = line.strip()$/;"	v
lineNo	tools/normMI.py	/^	lineNo = lineNo+1$/;"	v
lineNo	tools/normMI.py	/^lineNo = 1$/;"	v
list	tools/sortedEdgesToMetis.py	/^			list = [str(col_id)]$/;"	v
listgraphdef	Lib/struct.h	/^struct listgraphdef{$/;"	s
locator	Lib/struct.h	/^  idxtype *locator;$/;"	m	struct:PQueueType
log10BinCoeff	tools/evaluateClusters.py	/^def log10BinCoeff(n,x):$/;"	f
log10Perm	tools/evaluateClusters.py	/^def log10Perm(n,x):$/;"	f
log10fact	tools/evaluateClusters.py	/^def log10fact(n):$/;"	f
log2	Lib/rename.h	472;"	d
log2	Lib/util.c	/^int log2(int a)$/;"	f
logN	tools/normMI.py	/^logN = math.log(N,2)$/;"	v
logN_cluster	tools/normMI.py	/^logN_cluster = math.log(float(N_cluster),2)$/;"	v
lookForSingletons	Lib/util.c	/^idxtype* lookForSingletons(GraphType* graph, int* noOfSingletons)$/;"	f
m	tools/evaluateClusters.py	/^		m = float(intersects[gtCluster])$/;"	v
main	Programs/mergeClusters.c	/^int main(int argc, char *argv[])$/;"	f
main	Programs/mlrmcl.c	/^int main(int argc, char *argv[])$/;"	f
main	Programs/ncut.c	/^int main(int argc, char* argv[])$/;"	f
mapIndices	Lib/util.c	/^void mapIndices(idxtype *indices, idxtype* map, int n, int npart)$/;"	f
mapPartition	Lib/metrics.c	/^int mapPartition(idxtype* part, idxtype nvtxs)$/;"	f
matchType	Lib/struct.h	/^	int matchType;$/;"	m	struct:optionsdef
matrixdef	Lib/struct.h	/^struct matrixdef{$/;"	s
max	Lib/struct.h	/^  float max[2][MAXNCON];$/;"	m	struct:vpwgtdef
maxSize	tools/evaluateClusters.py	/^maxSize = int(args[6])$/;"	v
max_iters	Lib/struct.h	/^	int max_iters;$/;"	m	struct:pagerankOptionsDef
maxcore	Lib/struct.h	/^  int maxcore, ccore;$/;"	m	struct:workspacedef
maxgain	Lib/struct.h	/^  int maxgain;$/;"	m	struct:PQueueType
maxnodes	Lib/struct.h	/^  int maxnodes;$/;"	m	struct:PQueueType
maxvwgt	Lib/struct.h	/^  int maxvwgt;			\/* The maximum allowed weight for a vertex *\/$/;"	m	struct:controldef
maxwgt	Lib/struct.h	/^	wgttype* maxwgt; \/* max wgt of each column, assigned only$/;"	m	struct:matrixdef
meanp	tools/evaluateClusters.py	/^	meanp = sumPvalues\/l$/;"	v
mergeBestClusters	Lib/merge.c	/^void mergeBestClusters(ListGraph *cg, idxtype* part_mapper, int$/;"	f
mergeLists	Lib/merge.c	/^ListInt* mergeLists(const ListInt* al1, const ListWgt* wl1, $/;"	f
mi	tools/normMI.py	/^		mi = mi+t*u$/;"	v
mi	tools/normMI.py	/^mi = 0 # mutual information$/;"	v
minSize	tools/evaluateClusters.py	/^minSize = int(args[4])$/;"	v
mincut	Lib/struct.h	/^  int mincut, minvol;$/;"	m	struct:graphdef
minvol	Lib/struct.h	/^  int mincut, minvol;$/;"	m	struct:graphdef
mis_coarsenType	Lib/struct.h	/^	int mis_coarsenType;$/;"	m	struct:optionsdef
mis_projectFlow	Lib/mlmcl.c	/^Matrix* mis_projectFlow(Matrix* Mc, idxtype* rmap, int nvtxs)$/;"	f
mlmcl	Lib/mlmcl.c	/^void mlmcl(int* nvtxs, idxtype* xadj, idxtype* adjncy, idxtype$/;"	f
mlmclWithGraph	Lib/mlmcl.c	/^void mlmclWithGraph(GraphType *graph,idxtype* indices,Options opt)$/;"	f
mmdelm	Lib/rename.h	313;"	d
mmdint	Lib/rename.h	314;"	d
mmdnum	Lib/rename.h	315;"	d
mmdupd	Lib/rename.h	316;"	d
mustfree	Lib/struct.h	/^  int mustfree;$/;"	m	struct:PQueueType
my_AllocateWorkSpace	Lib/memory.c	/^void my_AllocateWorkSpace(CtrlType *ctrl, GraphType *graph )$/;"	f
my_CreateCoarseGraph	Lib/ccgraph.c	/^void my_CreateCoarseGraph(CtrlType *ctrl, GraphType *graph, int cnvtxs, idxtype *match, idxtype *perm)$/;"	f
my_Match_HEMN	Lib/match.c	/^void my_Match_HEMN(CtrlType *ctrl, GraphType *graph)$/;"	f
my_Match_PowerLaw_FC	Lib/match.c	/^void my_Match_PowerLaw_FC(CtrlType *ctrl, GraphType *graph)$/;"	f
my_Match_RM	Lib/match.c	/^void my_Match_RM(CtrlType *ctrl, GraphType *graph)$/;"	f
my_Match_SHEMN	Lib/match.c	/^void my_Match_SHEMN(CtrlType *ctrl, GraphType *graph)$/;"	f
my_SetUpCoarseGraph	Lib/ccgraph.c	/^GraphType* my_SetUpCoarseGraph(GraphType *graph, int cnvtxs)$/;"	f
my_SetUpGraph	Lib/graph.c	/^void my_SetUpGraph(GraphType *graph, int nvtxs, idxtype* xadj,$/;"	f
my_WriteMappedPartition	Lib/io.c	/^void my_WriteMappedPartition(const char *fname, idxtype *part, idxtype$/;"	f
my_WritePartition	Lib/io.c	/^void my_WritePartition(const char *fname, idxtype *part, int n, float gamma)$/;"	f
my_WritePartitionAddOne	Lib/io.c	/^void my_WritePartitionAddOne(const char *fname, idxtype *part, int n)$/;"	f
n	tools/evaluateClusters.py	/^		n = float(gtClusterSizes[gtCluster])$/;"	v
nbnd	Lib/struct.h	/^  int nbnd;$/;"	m	struct:graphdef
ncon	Lib/struct.h	/^  int ncon;			\/* The # of constrains *\/ $/;"	m	struct:graphdef
ncutify	Lib/struct.h	/^	int ncutify;$/;"	m	struct:optionsdef
ncutifyWeights	Lib/mclutils.c	/^void ncutifyWeights(Matrix* M, int hasWeightsAlready, int ncutify)$/;"	f
ndegrees	Lib/struct.h	/^ int ndegrees;          	\/* The number of different ext-degrees *\/$/;"	m	struct:rinfodef
ndegrees	Lib/struct.h	/^ int ndegrees;          	\/* The number of different ext-degrees *\/$/;"	m	struct:vrinfodef
ned	Lib/struct.h	/^  idxtype ed, ned;$/;"	m	struct:vedegreedef
nedges	Lib/struct.h	/^	int nedges;$/;"	m	struct:listgraphdef
nedges	Lib/struct.h	/^  int nvtxs, nedges;		\/* The # of vertices and edges in the graph *\/$/;"	m	struct:graphdef
next	Lib/struct.h	/^  struct ListNodeType *prev, *next;     \/* It's a doubly-linked list *\/$/;"	m	struct:ListNodeType	typeref:struct:ListNodeType::
ngainspan	Lib/struct.h	/^  int pgainspan, ngainspan;     \/* plus and negative gain span *\/$/;"	m	struct:PQueueType
nid	Lib/struct.h	/^ int id, ed, nid;            	\/* ID\/ED of nodes *\/$/;"	m	struct:vrinfodef
nmaxvwgt	Lib/struct.h	/^  float nmaxvwgt;		\/* The maximum allowed weight for a vertex for each constrain *\/$/;"	m	struct:controldef
nmi	tools/normMI.py	/^nmi = mi*2\/(h_gtc+h_cluster)$/;"	v
nnodes	Lib/struct.h	/^  int nnodes;$/;"	m	struct:PQueueType
nnz	Lib/struct.h	/^	int nvtxs, nnz; \/* nnz stands for number of non-zero$/;"	m	struct:matrixdef
noOfUnique	Lib/mclutils.c	/^int noOfUnique(idxtype* attrs,int n, idxtype* hashtable)$/;"	f
nodeId	tools/evaluateClusters.py	/^	nodeId = int(tokens[0])$/;"	v
nodes	Lib/struct.h	/^  ListNodeType *nodes;$/;"	m	struct:PQueueType
norm	tools/evaluateClusters.py	/^	norm = inputNormalizer$/;"	v
norm	tools/evaluateClusters.py	/^	norm = sumOfMs$/;"	v
normalizeColumns	Lib/mclutils.c	/^void normalizeColumns(Matrix* M, int hasWeightsAlready, int$/;"	f
npwgts	Lib/struct.h	/^  float *npwgts;		\/* The normalized partition weights *\/$/;"	m	struct:graphdef
nrinfo	Lib/struct.h	/^  NRInfoType *nrinfo;$/;"	m	struct:graphdef
nrinfodef	Lib/struct.h	/^struct nrinfodef {$/;"	s
nseps	Lib/struct.h	/^  int nseps;			\/* The number of separators to be found during multiple bisections *\/$/;"	m	struct:controldef
numDescendants	Lib/struct.h	/^  idxtype *numDescendants;$/;"	m	struct:graphdef
numEdges	tools/sortedEdgesToMetis.py	/^	numEdges=int(args[5])$/;"	v
numEdges	tools/sortedEdgesToMetis.py	/^	numEdges=wordcount(args[1])$/;"	v
numHashes	Lib/struct.h	/^	int numHashes;$/;"	m	struct:hashtabledef
numNodes	Lib/struct.h	/^	int numNodes;$/;"	m	struct:hashtabledef
numNodes	tools/sortedEdgesToMetis.py	/^numNodes = args[2]$/;"	v
numNodes	tools/sortedEdgesToMetis.py	/^numNodes = int(numNodes)$/;"	v
numPrunedEdges	tools/sortedEdgesToMetis.py	/^numPrunedEdges = 0$/;"	v
numWithoutAttractors	Lib/mclutils.c	/^int numWithoutAttractors(Matrix* M)$/;"	f
num_last_iter	Lib/struct.h	/^	int num_last_iter;$/;"	m	struct:optionsdef
nvtxs	Lib/struct.h	/^	int nvtxs, nnz; \/* nnz stands for number of non-zero$/;"	m	struct:matrixdef
nvtxs	Lib/struct.h	/^	int nvtxs;$/;"	m	struct:listgraphdef
nvtxs	Lib/struct.h	/^	int nvtxs;$/;"	m	struct:threadData
nvtxs	Lib/struct.h	/^  int nvtxs, nedges;		\/* The # of vertices and edges in the graph *\/$/;"	m	struct:graphdef
nvwgt	Lib/struct.h	/^  float *nvwgt;			\/* Normalized vertex weights *\/$/;"	m	struct:graphdef
oflags	Lib/struct.h	/^  int oflags;$/;"	m	struct:controldef
optionsdef	Lib/struct.h	/^struct optionsdef{$/;"	s
optype	Lib/struct.h	/^  int optype;			\/* Type of operation *\/$/;"	m	struct:controldef
outClusters	tools/evaluateClusters.py	/^outClusters = converttoclusterlists(args[1])$/;"	v
outLine	tools/sortedEdgesToMetis.py	/^		outLine = [str(col_id)]$/;"	v
pagerank	Lib/struct.h	/^  wgttype *pagerank;$/;"	m	struct:graphdef
pagerankOptionsDef	Lib/struct.h	/^struct pagerankOptionsDef{$/;"	s
penalty_power	Lib/struct.h	/^	float penalty_power; \/\/ used in transformAdj$/;"	m	struct:optionsdef
permArrays	tools/evaluateClusters.py	/^permArrays = {}$/;"	v
permuteDegreeOrder	Lib/util.c	/^void permuteDegreeOrder(int n, idxtype *p, idxtype *xadj)$/;"	f
permuteRowsAndColumns	Lib/mclutils.c	/^Matrix* permuteRowsAndColumns(Matrix *M, idxtype* rowPerm, idxtype* colPerm)$/;"	f
permuteRowsAndColumns	Lib/mclutils.c	/^Matrix* permuteRowsAndColumns(Matrix* M, idxtype* perm)$/;"	f
pfactor	Lib/struct.h	/^  int pfactor;			\/* .1*prunning factor *\/$/;"	m	struct:controldef
pgainspan	Lib/struct.h	/^  int pgainspan, ngainspan;     \/* plus and negative gain span *\/$/;"	m	struct:PQueueType
pid	Lib/struct.h	/^  idxtype pid;$/;"	m	struct:edegreedef
pid	Lib/struct.h	/^  idxtype pid;$/;"	m	struct:vedegreedef
pmat	Lib/struct.h	/^  idxtype *pmat;			\/* An array of k^2 used for eliminating domain $/;"	m	struct:workspacedef
prec	tools/evaluateClusters.py	/^		prec = m\/M$/;"	v
prev	Lib/struct.h	/^  struct ListNodeType *prev, *next;     \/* It's a doubly-linked list *\/$/;"	m	struct:ListNodeType	typeref:struct:ListNodeType::ListNodeType
printHistogram	Lib/io.c	/^void printHistogram(idxtype* hist, int maxDegree, FILE* fp)$/;"	f
printRow	Lib/mclutils.c	/^void printRow(Matrix *M, int row)$/;"	f
print_help	Programs/mergeClusters.c	/^void print_help(const char * program_name)$/;"	f
print_help	Programs/mlrmcl.c	/^void print_help(char program_name[])$/;"	f
print_help	Programs/ncut.c	/^void print_help(char program_name[])$/;"	f
propagateFlow	Lib/mlmcl.c	/^Matrix* propagateFlow(Matrix* cm, GraphType* cgraph, GraphType*$/;"	f
pruneAndNormalize	Lib/mclbase.c	/^void pruneAndNormalize(Matrix* a, int exact, int k)$/;"	f
prunePercent	Lib/struct.h	/^	wgttype prunePercent;$/;"	m	struct:dirToUndirOptionsDef
pvalue	tools/evaluateClusters.py	/^				pvalue = NbinCoeffs[M]$/;"	v
pvalue	tools/evaluateClusters.py	/^				pvalue = NbinCoeffs[N-M]$/;"	v
pvalue	tools/evaluateClusters.py	/^				pvalue = log10BinCoeff(N,M)$/;"	v
pvalue	tools/evaluateClusters.py	/^			pvalue = pvalue - subtract$/;"	v
pvalueThreshold	tools/evaluateClusters.py	/^pvalueThreshold = 2 #significance threshold is 0.01$/;"	v
pwgts	Lib/struct.h	/^  idxtype *where, *pwgts;$/;"	m	struct:graphdef
rdata	Lib/struct.h	/^  idxtype *gdata, *rdata;	\/* Memory pools for graph and refinement data.$/;"	m	struct:graphdef
readClustering	Lib/io.c	/^int readClustering(const char *filename, int *part, int nvtex){$/;"	f
readMemberships	Lib/io.c	/^void readMemberships( char *file, int numMemberships, idxtype$/;"	f
rec	tools/evaluateClusters.py	/^		rec = m\/n$/;"	v
regexp	tools/normMI.py	/^regexp = re.compile("\\\\s+")$/;"	v
regexp	tools/sortedEdgesToMetis.py	/^regexp = re.compile("\\\\s+")$/;"	v
removeHubs	Lib/subgraphs.c	/^idxtype* removeHubs(GraphType *graph, int threshold, int wgtflag,$/;"	f
removeSelfLoops	Lib/mclutils.c	/^Matrix* removeSelfLoops(Matrix* M, int normalizeColumns)$/;"	f
removeSelfLoops	Lib/mclutils.c	/^void removeSelfLoops(GraphType* g)$/;"	f
ret	Lib/struct.h	/^	Matrix **ret;$/;"	m	struct:threadData
ret_adjncy	Lib/struct.h	/^	idxtype **ret_xadj, **ret_adjncy, **ret_adjwgt;$/;"	m	struct:threadData
ret_adjwgt	Lib/struct.h	/^	idxtype **ret_xadj, **ret_adjncy, **ret_adjwgt;$/;"	m	struct:threadData
ret_xadj	Lib/struct.h	/^	idxtype **ret_xadj, **ret_adjncy, **ret_adjwgt;$/;"	m	struct:threadData
rinfo	Lib/struct.h	/^  RInfoType *rinfo;$/;"	m	struct:graphdef
rinfodef	Lib/struct.h	/^struct rinfodef {$/;"	s
rmap	Lib/struct.h	/^	idxtype* rmap; \/* This is for mis_coarsen *\/$/;"	m	struct:matrixdef
rmap1	Lib/struct.h	/^  idxtype *rmap1;$/;"	m	struct:graphdef
rmap2	Lib/struct.h	/^  idxtype *rmap2;$/;"	m	struct:graphdef
row_id	tools/sortedEdgesToMetis.py	/^	row_id = int(float(tokens[0]))$/;"	v
row_id	tools/sortedEdgesToMetis.py	/^	row_id = row_id + 1$/;"	v
rx	tools/evaluateClusters.py	/^rx=re.compile("\\\\s+")$/;"	v
s	tools/sortedEdgesToMetis.py	/^				s = s + " " + ' '.join(adjListMap[current_row_id])$/;"	v
s	tools/sortedEdgesToMetis.py	/^			s = ' '.join(outLine)$/;"	v
s	tools/sortedEdgesToMetis.py	/^	s = s + " " + ' '.join(adjListMap[row_id])$/;"	v
s	tools/sortedEdgesToMetis.py	/^s = ' '.join(outLine)$/;"	v
samax	Lib/rename.h	454;"	d
samax	Lib/util.c	/^int samax(int n, float *x)$/;"	f
samax2	Lib/rename.h	455;"	d
samax2	Lib/util.c	/^int samax2(int n, float *x)$/;"	f
samin	Lib/rename.h	457;"	d
samin	Lib/util.c	/^int samin(int n, float *x)$/;"	f
saxpy	Lib/rename.h	468;"	d
saxpy	Lib/util.c	/^void saxpy(int n, float alpha, float *x, int incx, float *y, int incy)$/;"	f
scale	Lib/struct.h	/^	wgttype scale;$/;"	m	struct:dirToUndirOptionsDef
scopy	Lib/macros.h	102;"	d
sdot	Lib/rename.h	467;"	d
sdot	Lib/util.c	/^float sdot(int n, float *x, float *y)$/;"	f
seconds	Lib/rename.h	434;"	d
seconds	Lib/util.c	/^double seconds(void)$/;"	f
setupCanonicalMatrix	Lib/mclutils.c	/^Matrix* setupCanonicalMatrix(int nvtxs, int nedges, idxtype* xadj,$/;"	f
siqst	Lib/myqsort.c	/^static void siqst(idxtype *base, idxtype *max)$/;"	f	file:
size	tools/evaluateClusters.py	/^	size = int(tokens[0])$/;"	v
sizeIncrement	Lib/struct.h	/^	int sizeIncrement;$/;"	m	struct:matrixdef
snorm2	Lib/rename.h	466;"	d
snorm2	Lib/util.c	/^float snorm2(int n, float *v)$/;"	f
sortAdjLists	Lib/mclutils.c	/^void sortAdjLists(int nvtxs, idxtype* xadj, idxtype* adjncy, wgttype* adjwgt)$/;"	f
sortedNodeIds	Lib/struct.h	/^	idxtype *sortedNodeIds; $/;"	m	struct:hashtabledef
sscale	Lib/rename.h	465;"	d
sscale	Lib/util.c	/^void sscale(int n, float alpha, float *x)$/;"	f
sset	Lib/rename.h	450;"	d
sset	Lib/util.c	/^float *sset(int n, float val, float *x)$/;"	f
ssum	Lib/rename.h	463;"	d
ssum	Lib/util.c	/^float ssum(int n, float *x)$/;"	f
ssum_strd	Lib/rename.h	464;"	d
ssum_strd	Lib/util.c	/^float ssum_strd(int n, float *x, int incx)$/;"	f
starttimer	Lib/macros.h	112;"	d
stdDev	tools/evaluateClusters.py	/^	stdDev = l*sumSquaresPvalues - sumPvalues*sumPvalues$/;"	v
stdDev	tools/evaluateClusters.py	/^	stdDev = math.sqrt(stdDev)$/;"	v
stdDev	tools/evaluateClusters.py	/^	stdDev = stdDev \/ (l*(l-1))$/;"	v
stdDeviation	Lib/metrics.c	/^float stdDeviation(idxtype* values, int n)$/;"	f
stoptimer	Lib/macros.h	113;"	d
subtract	tools/evaluateClusters.py	/^			subtract = log10BinCoeff(n,m) +	log10BinCoeff(N-n,M-m)	$/;"	v
sumOfMs	tools/evaluateClusters.py	/^	sumOfMs = sumOfMs + len(cluster)$/;"	v
sumOfMs	tools/evaluateClusters.py	/^sumOfMs = 0$/;"	v
sumPvalues	tools/evaluateClusters.py	/^	sumPvalues = sumPvalues + bestpvalue$/;"	v
sumPvalues	tools/evaluateClusters.py	/^sumPvalues = float(0)$/;"	v
sumSquaresPvalues	tools/evaluateClusters.py	/^	sumSquaresPvalues = sumSquaresPvalues +	bestpvalue*bestpvalue$/;"	v
sumSquaresPvalues	tools/evaluateClusters.py	/^sumSquaresPvalues = float(0)$/;"	v
swapidxtype	Lib/mclbase.c	/^void swapidxtype(idxtype* a, idxtype* b)$/;"	f
swapwgttype	Lib/mclbase.c	/^void swapwgttype(wgttype* a, wgttype* b)$/;"	f
t	tools/normMI.py	/^		t = gtccCount\/N$/;"	v
t	tools/normMI.py	/^	t = regexp.split(line.strip())$/;"	v
testCoarsening	Lib/mclutils.c	/^void testCoarsening(int *nvtxs, idxtype *xadj, idxtype *adjncy,$/;"	f
threadData	Lib/struct.h	/^struct threadData {$/;"	s
threshPrune	Lib/mclbase.c	/^wgttype threshPrune(int *n, idxtype* adjncy, wgttype* adjwgt,$/;"	f
threshold	Lib/struct.h	/^	float threshold;$/;"	m	struct:threadData
threshold	Lib/struct.h	/^	wgttype threshold;$/;"	m	struct:dirToUndirOptionsDef
timer	Lib/struct.h	/^typedef double timer;$/;"	t
tokens	tools/evaluateClusters.py	/^	tokens = rx.split(line)$/;"	v
tokens	tools/sortedEdgesToMetis.py	/^	tokens = regexp.split(line.strip())$/;"	v
transformAdj	Lib/mclbase.c	/^Matrix* transformAdj(Matrix* flows, Matrix* input_adj, $/;"	f
transformAdj	Lib/struct.h	/^	int transformAdj;$/;"	m	struct:optionsdef
type	Lib/struct.h	/^  int type;                     \/* The type of the representation used *\/$/;"	m	struct:PQueueType
u	tools/normMI.py	/^		u = logN+math.log(gtccCount,2)-gtcCount-math.log(clusterCount,2)$/;"	v
val	Lib/struct.h	/^  idxtype val;$/;"	m	struct:KeyValueType
vedegreedef	Lib/struct.h	/^struct vedegreedef {$/;"	s
vedegrees	Lib/struct.h	/^  VEDegreeType *vedegrees;$/;"	m	struct:workspacedef
vols	Lib/struct.h	/^	wgttype* vols; \/\/ volumes, i.e. sum of edge weights$/;"	m	struct:listgraphdef
vpwgtdef	Lib/struct.h	/^struct vpwgtdef {$/;"	s
vrinfo	Lib/struct.h	/^  VRInfoType *vrinfo;$/;"	m	struct:graphdef
vrinfodef	Lib/struct.h	/^struct vrinfodef {$/;"	s
vsize	Lib/struct.h	/^  idxtype *vsize;		\/* Vertex sizes for min-volume formulation *\/$/;"	m	struct:graphdef
vwgt	Lib/struct.h	/^  idxtype *vwgt;		\/* Vertex weights *\/$/;"	m	struct:graphdef
wavgF	tools/evaluateClusters.py	/^	wavgF = wgtdAvgF \/ normalizer$/;"	v
wavgP	tools/evaluateClusters.py	/^	wavgP = wgtdAvgP \/ normalizer$/;"	v
wavgR	tools/evaluateClusters.py	/^	wavgR = wgtdAvgR \/ normalizer$/;"	v
weights	tools/sortedEdgesToMetis.py	/^	weights = False$/;"	v
weights	tools/sortedEdgesToMetis.py	/^	weights = True$/;"	v
weights	tools/sortedEdgesToMetis.py	/^weights = int(args[3])$/;"	v
wgtLists	Lib/struct.h	/^	ListWgt* wgtLists;$/;"	m	struct:listgraphdef
wgtMap	tools/sortedEdgesToMetis.py	/^wgtMap = {}$/;"	v
wgtdAvgF	tools/evaluateClusters.py	/^	wgtdAvgF = wgtdAvgF + M*bestf$/;"	v
wgtdAvgF	tools/evaluateClusters.py	/^wgtdAvgF = float(0)$/;"	v
wgtdAvgP	tools/evaluateClusters.py	/^	wgtdAvgP = wgtdAvgP + M*bestp$/;"	v
wgtdAvgP	tools/evaluateClusters.py	/^wgtdAvgP = float(0)$/;"	v
wgtdAvgR	tools/evaluateClusters.py	/^	wgtdAvgR = wgtdAvgR + M*bestr$/;"	v
wgtdAvgR	tools/evaluateClusters.py	/^wgtdAvgR = float(0)$/;"	v
wgtlistdef	Lib/struct.h	/^struct wgtlistdef{$/;"	s
wgtset	Lib/util.c	/^wgttype* wgtset(int n, wgttype val, wgttype *x)$/;"	f
wgttype	Lib/struct.h	/^typedef double wgttype;$/;"	t
wgttype	Lib/struct.h	/^typedef float wgttype;$/;"	t
where	Lib/struct.h	/^  idxtype *where, *pwgts;$/;"	m	struct:graphdef
wordcount	tools/wordCount.py	/^def wordcount(fname, needwords=False):$/;"	f
workspacedef	Lib/struct.h	/^struct workspacedef {$/;"	s
wspace	Lib/struct.h	/^  WorkSpaceType wspace;		\/* Work Space Informations *\/$/;"	m	struct:controldef
wt	tools/sortedEdgesToMetis.py	/^		wt = float(tokens[2])$/;"	v
xadj	Lib/struct.h	/^	idxtype *xadj, *adjncy, *adjwgt;$/;"	m	struct:threadData
xadj	Lib/struct.h	/^	idxtype* xadj; \/* xadj[i+1]-xadj[i] gives the number of$/;"	m	struct:matrixdef
xadj	Lib/struct.h	/^  idxtype *xadj;		\/* Pointers to the locally stored vertices *\/$/;"	m	struct:graphdef
